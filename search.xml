<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动作识别新模型--多维度细化图卷积网络源码和论文现已发布在github。</title>
    <url>/2023/06/28/MDRGCN/</url>
    <content><![CDATA[<p>我们发布了文章：Multi-Dimensional Refinement Graph Convolutional Network with Robust Decouple Loss for Fine-Grained Skeleton-Based Action Recognition</p>
<p>pdf链接：<a href="https://arxiv.org/abs/2306.15321">https://arxiv.org/abs/2306.15321</a></p>
<p>代码链接：<a href="https://github.com/dingyn-Reno/MDR-GCN/blob/main/README.md">https://github.com/dingyn-Reno/MDR-GCN/blob/main/README.md</a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Graph convolutional networks have been widely used in skeleton-based action recognition. However, existing approaches are limited in fine-grained action recognition due to the similarity of inter-class data. Moreover, the noisy data from pose extraction increases the challenge of fine-grained recognition. In this work, we propose a flexible attention block called Channel-Variable Spatial-Temporal Attention (CVSTA) to enhance the discriminative power of spatial-temporal joints and obtain a more compact intra-class feature distribution. Based on CVSTA, we construct a Multi-Dimensional Refinement Graph Convolutional Network (MDR-GCN), which can improve the discrimination among channel-, joint- and frame-level features for fine-grained actions. Furthermore, we propose a Robust Decouple Loss (RDL), which significantly boosts the effect of the CVSTA and reduces the impact of noise. The proposed method combining MDR-GCN with RDL outperforms the known state- of-the-art skeleton-based approaches on fine-grained datasets, FineGym99 and FSD-10, and also on the coarse dataset NTU- RGB+D X-view version.</p>
<h2 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h2><h3 id="FineGym99"><a href="#FineGym99" class="headerlink" title="FineGym99"></a>FineGym99</h3><p>The data processing is borrowed from <a href="https://github.com/kennymckormick/pyskl">https://github.com/kennymckormick/pyskl</a></p>
<h3 id="NTU-RGB-D"><a href="#NTU-RGB-D" class="headerlink" title="NTU RGB+D"></a>NTU RGB+D</h3><p>Request dataset: <a href="https://rose1.ntu.edu.sg/dataset/actionRecognition">https://rose1.ntu.edu.sg/dataset/actionRecognition</a></p>
<p>The data processing is borrowed from CTR-GCN: <a href="https://github.com/Uason-Chen/CTR-GCN">https://github.com/Uason-Chen/CTR-GCN</a></p>
<h3 id="FSD-10"><a href="#FSD-10" class="headerlink" title="FSD-10"></a>FSD-10</h3><p>Request dataset: <a href="https://shenglanliu.github.io/fsd10/">https://shenglanliu.github.io/fsd10/</a></p>
<h2 id="Train"><a href="#Train" class="headerlink" title="Train"></a>Train</h2><p>For FineGym99,<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python main_cl_new.py --config config/gym/default2.yaml --device 0</span><br></pre></td></tr></table></figure></p>
<p>For NTU RGB+D,<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python main_cl_new.py --config config/nturgbd-cross-subject/default.yaml --device 0</span><br></pre></td></tr></table></figure></p>
<p>After all modalities, ensemble the results of different modalities, run<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python ensemble.py --dataset ntu/xsub --joint-dir work_dir/ntu60/xsub/FTS_joint --bone-dir work_dir/ntu60/xsub/FTS_bone --joint-motion-dir work_dir/ntu60/xsub/FTS_jointM --bone-motion-dir work_dir/ntu60/xsub/FTS_BoneM</span><br></pre></td></tr></table></figure></p>
<p>For FSD-10,<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python main_cl_new.py --config config/skat/train_25.yaml --device 0</span><br></pre></td></tr></table></figure></p>
<h2 id="Citation"><a href="#Citation" class="headerlink" title="Citation"></a>Citation</h2><p>If you find our work useful in your research, please consider citing:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@misc&#123;liu2023multidimensional,</span><br><span class="line">      title=&#123;Multi-Dimensional Refinement Graph Convolutional Network with Robust Decouple Loss for Fine-Grained Skeleton-Based Action Recognition&#125;, </span><br><span class="line">      author=&#123;Sheng-Lan Liu and Yu-Ning Ding and Jin-Rong Zhang and Kai-Yuan Liu and Si-Fan Zhang and Fei-Long Wang and Gao Huang&#125;,</span><br><span class="line">      year=&#123;2023&#125;,</span><br><span class="line">      eprint=&#123;2306.15321&#125;,</span><br><span class="line">      archivePrefix=&#123;arXiv&#125;,</span><br><span class="line">      primaryClass=&#123;cs.CV&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>骨骼点动作识别</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorRT的细粒度profilling--trtexec</title>
    <url>/2023/06/24/tensort-trtexec/</url>
    <content><![CDATA[<h2 id="trtexec"><a href="#trtexec" class="headerlink" title="trtexec"></a>trtexec</h2><p>TensorRT中的<code>trtexec</code>可以用来评测我们的网络模型，具体来说它有以下两个功能：</p>
<p> 被用来对指定网络模型产生序列化引擎。</p>
<p>示例命令：<code>trtexec --deploy=/path/to/mnist.prototxt --model=/path/to/mnist.caffemodel --output=prob --batch=16 --saveEngine=mnist16.trt</code> (linux)</p>
<p>被用来在指定的网络模型中，对随机输入数据进行基准测试。</p>
<p>示例命令：<code>trtexec --loadEngine=mnist16.trt --batch=16</code></p>
<p>如果你想测试 FP16 的性能，你可以通过新增一个参数<code>--fp16</code>来实现，但并不是所有的 NVIDIA GPU 系列都支持 FP16 或者说 FP16 模式都有加速效果，</p>
<p>我们对我们在上文编译的CTR-GCN模型进行profilling。</p>
<p>编译<code>samples/trtexec/</code></p>
<p>执行命令<code>./trtexec --onnx=model.onnx --shapes=input:1x3x64x17x1</code></p>
<h3 id="work-with-chatgpt"><a href="#work-with-chatgpt" class="headerlink" title="work with chatgpt"></a>work with chatgpt</h3><p>我们遇到了很多bug，在这个过程中和chatgpt进行了多次沟通</p>
<h3 id="Q-tensorrt的工具trtexec怎么用"><a href="#Q-tensorrt的工具trtexec怎么用" class="headerlink" title="Q: tensorrt的工具trtexec怎么用"></a>Q: tensorrt的工具trtexec怎么用</h3><p>A: TensorRT的工具<code>trtexec</code>是一个用于执行和测试TensorRT模型的命令行实用程序。它提供了一些选项，用于配置和运行TensorRT引擎。</p>
<p>以下是<code>trtexec</code>的一般用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trtexec [选项] &lt;模型文件&gt;</span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;模型文件&gt;</code>是您要使用TensorRT运行的模型文件路径。下面是一些常用的选项：</p>
<ul>
<li><code>-d</code> 或 <code>--deploy</code>：指定Caffe或ONNX模型的deploy文件路径。</li>
<li><code>-s</code> 或 <code>--scales</code>：指定输入张量的缩放因子。例如：<code>--scales=1.0,1.0,1.0</code>。</li>
<li><code>-e</code> 或 <code>--explicitBatch</code>：将批次大小设置为显式值。例如：<code>--explicitBatch=1</code>。</li>
<li><code>-t</code> 或 <code>--timing</code>：启用TensorRT引擎的时间测量。</li>
<li><code>-v</code> 或 <code>--verbose</code>：启用详细的日志输出。</li>
</ul>
<p>此外，还可以使用其他选项来配置TensorRT引擎和运行时设置。您可以使用<code>trtexec --help</code>命令查看完整的选项列表和说明。</p>
<p>以下是一个示例使用<code>trtexec</code>运行TensorRT模型的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trtexec --deploy=deploy.prototxt --explicitBatch=1 --scales=1.0,1.0,1.0 model.trt</span><br></pre></td></tr></table></figure>
<p>该命令使用Caffe的deploy文件(<code>deploy.prototxt</code>)和TensorRT模型文件(<code>model.trt</code>)来运行TensorRT引擎。它设置了批次大小为1，并使用缩放因子1.0来处理输入张量。</p>
<p>请注意，<code>trtexec</code>工具需要正确配置的TensorRT库和CUDA环境。在运行之前，请确保您已经正确安装和设置了相关的依赖项。</p>
<p>希望这可以帮助您开始使用<code>trtexec</code>工具来执行和测试TensorRT模型。如有需要，请参考TensorRT文档获取更多详细信息和示例。</p>
<h3 id="Q：我如何使用trtexec来生成onnx模型的序列化引擎"><a href="#Q：我如何使用trtexec来生成onnx模型的序列化引擎" class="headerlink" title="Q：我如何使用trtexec来生成onnx模型的序列化引擎"></a>Q：我如何使用trtexec来生成onnx模型的序列化引擎</h3><p>A：要使用<code>trtexec</code>工具生成TensorRT的序列化引擎（Serialized Engine）文件，您需要提供一个Caffe或ONNX模型的deploy文件，并使用<code>--onnx</code>选项指定输出的引擎文件名。</p>
<p>以下是使用<code>trtexec</code>生成序列化引擎的示例命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trtexec --onnx=&lt;输出引擎文件名&gt; --deploy=&lt;Caffe或ONNX模型的deploy文件&gt; [其他选项]</span><br></pre></td></tr></table></figure>
<p>请确保将<code>&lt;输出引擎文件名&gt;</code>替换为您希望生成的TensorRT引擎文件的路径和文件名。<code>&lt;Caffe或ONNX模型的deploy文件&gt;</code>应该是您要使用的模型的deploy文件路径。</p>
<p>此外，您可以根据需要添加其他选项来配置TensorRT引擎和运行时设置。例如，您可以使用<code>--explicitBatch</code>选项设置批次大小，使用<code>--scales</code>选项设置输入张量的缩放因子等。</p>
<p>以下是一个示例命令，展示如何使用<code>trtexec</code>生成ONNX模型的序列化引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trtexec --onnx=model.engine --deploy=model.prototxt</span><br></pre></td></tr></table></figure>
<p>该命令将使用名为<code>model.prototxt</code>的Caffe或ONNX模型的deploy文件，并将生成的TensorRT引擎保存为<code>model.engine</code>文件。</p>
<p>请确保在运行命令之前已正确配置TensorRT库和CUDA环境，并且相关的依赖项已正确安装和设置。</p>
<p>希望这可以帮助您使用<code>trtexec</code>工具生成ONNX模型的序列化引擎。如有需要，请参考TensorRT文档获取更多详细信息和示例。</p>
<h3 id="Q-onnx如何生成deploy文件"><a href="#Q-onnx如何生成deploy文件" class="headerlink" title="Q: onnx如何生成deploy文件"></a>Q: onnx如何生成deploy文件</h3><p>A：在TensorRT中，<code>deploy</code>文件通常与Caffe模型相关联，而不是与ONNX模型关联。<code>deploy</code>文件是Caffe框架中的一种描述网络结构的文件，其中包含了网络的层次结构、参数等信息。因此，您无法直接从ONNX模型生成<code>deploy</code>文件。</p>
<p>如果您有一个ONNX模型，并且希望在TensorRT中使用，可以通过以下步骤将ONNX模型转换为TensorRT可用的格式：</p>
<ol>
<li>使用TensorRT的Python API加载ONNX模型。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorrt <span class="keyword">as</span> trt</span><br><span class="line"></span><br><span class="line">TRT_LOGGER = trt.Logger(trt.Logger.WARNING)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_engine</span>(<span class="params">onnx_file_path</span>):</span><br><span class="line">    builder = trt.Builder(TRT_LOGGER)</span><br><span class="line">    network = builder.create_network()</span><br><span class="line">    parser = trt.OnnxParser(network, TRT_LOGGER)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(onnx_file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> model:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> parser.parse(model.read()):</span><br><span class="line">            <span class="keyword">for</span> error <span class="keyword">in</span> <span class="built_in">range</span>(parser.num_errors):</span><br><span class="line">                <span class="built_in">print</span>(parser.get_error(error))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    builder.max_batch_size = <span class="number">1</span></span><br><span class="line">    builder.max_workspace_size = <span class="number">1</span> &lt;&lt; <span class="number">30</span>  <span class="comment"># 设置适当的workspace大小</span></span><br><span class="line">    engine = builder.build_cuda_engine(network)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> engine</span><br></pre></td></tr></table></figure>
<ol>
<li>将加载的ONNX模型转换为TensorRT引擎。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">onnx_file_path = <span class="string">&#x27;model.onnx&#x27;</span></span><br><span class="line">engine = build_engine(onnx_file_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> engine <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    trt_engine_path = <span class="string">&#x27;model.trt&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(trt_engine_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(engine.serialize())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;TensorRT engine saved at:&quot;</span>, trt_engine_path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Failed to build TensorRT engine.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上述代码片段中的<code>build_engine</code>函数将ONNX模型解析为TensorRT的网络表示，并使用TensorRT的Builder构建引擎。最后，引擎通过<code>serialize</code>方法序列化为文件，并保存为<code>.trt</code>文件。</p>
<p>使用上述代码，您可以将ONNX模型转换为TensorRT的序列化引擎文件，而无需使用<code>deploy</code>文件。</p>
<h3 id="Q：我应该如何使用tensorrt的trtexec测试onnx模型文件"><a href="#Q：我应该如何使用tensorrt的trtexec测试onnx模型文件" class="headerlink" title="Q：我应该如何使用tensorrt的trtexec测试onnx模型文件"></a>Q：我应该如何使用tensorrt的trtexec测试onnx模型文件</h3><p>A：要使用TensorRT的<code>trtexec</code>工具测试ONNX模型文件，您需要遵循以下步骤：</p>
<ol>
<li><p>下载并安装TensorRT。确保您已正确安装并配置了TensorRT库和CUDA环境。</p>
</li>
<li><p>在命令行中使用<code>trtexec</code>命令来执行ONNX模型。命令的基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trtexec --onnx=&lt;模型文件&gt; [其他选项]</span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;模型文件&gt;</code>是您要测试的ONNX模型文件路径。您可以根据需要添加其他选项来配置TensorRT引擎和运行时设置。</p>
<p>以下是一些常用的选项：</p>
<ul>
<li><code>-s</code> 或 <code>--shapes</code>：指定输入张量的形状。例如：<code>--shapes=input:1x3x224x224</code>。</li>
<li><code>-e</code> 或 <code>--explicitBatch</code>：将批次大小设置为显式值。例如：<code>--explicitBatch=1</code>。</li>
<li><code>-t</code> 或 <code>--timing</code>：启用TensorRT引擎的时间测量。</li>
<li><code>-v</code> 或 <code>--verbose</code>：启用详细的日志输出。</li>
</ul>
<p>请使用<code>trtexec --help</code>命令查看完整的选项列表和说明。</p>
</li>
<li><p>运行<code>trtexec</code>命令来测试ONNX模型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trtexec --onnx=model.onnx --shapes=input:1x3x224x224</span><br></pre></td></tr></table></figure>
<p>这个命令会使用名为<code>model.onnx</code>的ONNX模型文件来运行TensorRT引擎。它还指定了输入张量的形状为<code>1x3x224x224</code>。</p>
<p><code>trtexec</code>将加载模型并执行推理，然后显示一些有关推理性能的信息，例如每个层的执行时间和推理总时间。</p>
</li>
</ol>
<p>请注意，<code>trtexec</code>工具需要正确配置的TensorRT库和CUDA环境。在运行之前，请确保您已经正确安装和设置了相关的依赖项。</p>
<p>希望这可以帮助您使用<code>trtexec</code>工具测试ONNX模型文件。如有需要，请参考TensorRT文档获取更多详细信息和示例。</p>
]]></content>
      <categories>
        <category>模型部署优化</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorrt入门第一课--a tensorrt python demo</title>
    <url>/2023/05/24/tensorrt-python-demp/</url>
    <content><![CDATA[<h2 id="python-tensorRT入门示例"><a href="#python-tensorRT入门示例" class="headerlink" title="python tensorRT入门示例"></a>python tensorRT入门示例</h2><blockquote>
<p>安装pycuda时报错”Could not build wheels for pycuda, which is required to install pyproject.toml-based projects”的解决方案</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CPATH=<span class="variable">$CPATH</span>:/usr/local/cuda-11.8/targets/x86_64-linux/include</span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$LIBRARY_PATH</span>:/usr/local/cuda-11.8/targets/x86_64-linux/lib</span><br><span class="line">pip install pycuda</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以下是此示例应用程序的四个步骤：</p>
<ol>
<li>将 PyTorch 模型转换为 ONNX 。</li>
<li>将 ONNX 模型导入到 TensorRT 中。</li>
<li>应用优化并生成引擎。</li>
<li>对 GPU 执行推理。</li>
</ol>
<p>我们使用骨骼点动作识别模型CTR-GCN来进行本次实验</p>
<h3 id="1-将-PyTorch-模型转换为-ONNX"><a href="#1-将-PyTorch-模型转换为-ONNX" class="headerlink" title="1 将 PyTorch 模型转换为 ONNX"></a>1 将 PyTorch 模型转换为 ONNX</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.onnx</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> ctrgcn_infer <span class="keyword">as</span> ctrgcn</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">import_class</span>(<span class="params">name</span>):</span><br><span class="line">    components = name.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    mod = <span class="built_in">__import__</span>(components[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> comp <span class="keyword">in</span> components[<span class="number">1</span>:]:</span><br><span class="line">        mod = <span class="built_in">getattr</span>(mod, comp)</span><br><span class="line">    <span class="keyword">return</span> mod</span><br><span class="line"></span><br><span class="line">is_compile=<span class="literal">False</span></span><br><span class="line">torch_model=ctrgcn.Model(num_class=<span class="number">99</span>,num_point=<span class="number">17</span>,num_person=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 转换的onnx格式的名称，文件后缀需为.onnx</span></span><br><span class="line">onnx_file_name = <span class="string">&quot;model.onnx&quot;</span></span><br><span class="line"><span class="comment"># 我们需要转换的模型，将torch_model设置为自己的模型</span></span><br><span class="line">model = torch_model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用编译模式，会进行以下操作</span></span><br><span class="line"><span class="keyword">if</span> is_compile==<span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">import</span> torch._dynamo</span><br><span class="line">    torch._dynamo.config.suppress_errors = <span class="literal">True</span></span><br><span class="line">    model=torch.<span class="built_in">compile</span>(model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载权重，将model.pth转换为自己的模型权重</span></span><br><span class="line"><span class="comment"># 如果模型的权重是使用多卡训练出来，我们需要去除权重中多的module. 具体操作可以见5.4节</span></span><br><span class="line">weights=torch.load(<span class="string">&quot;/home/dingyuning/tensorrt_demo/work_dir/gym/ctr1/runs-99-31680.pt&quot;</span>)</span><br><span class="line">weights = OrderedDict([[k.split(<span class="string">&#x27;module.&#x27;</span>)[-<span class="number">1</span>], v.cpu()] <span class="keyword">for</span> k, v <span class="keyword">in</span> weights.items()])</span><br><span class="line">state=model.state_dict()</span><br><span class="line">keys = <span class="built_in">list</span>(weights.keys())</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> state:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; not found&#x27;</span>.<span class="built_in">format</span>(k))</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> state:</span><br><span class="line">    <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> keys:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;missing param &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(k))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    model.load_state_dict(weights)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    state = model.state_dict()</span><br><span class="line">    diff = <span class="built_in">list</span>(<span class="built_in">set</span>(state.keys()).difference(<span class="built_in">set</span>(weights.keys())))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Can not find these weights:&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> diff:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;  &#x27;</span> + d)</span><br><span class="line">    state.update(weights)</span><br><span class="line">    model.load_state_dict(state)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出模型前，必须调用model.eval()或者model.train(False)</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">1</span> <span class="comment"># 随机的取值，当设置dynamic_axes后影响不大</span></span><br><span class="line">dummy_input = torch.randn(batch_size, <span class="number">3</span>,<span class="number">64</span>,<span class="number">17</span>,<span class="number">1</span>) <span class="comment"># dummy_input就是一个输入的实例，仅提供输入shape、type等信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这组输入对应的模型输出</span></span><br><span class="line">output = model(dummy_input)</span><br><span class="line"><span class="comment"># 导出模型</span></span><br><span class="line">torch.onnx.export(model,        <span class="comment"># 模型的名称</span></span><br><span class="line">                  dummy_input,   <span class="comment"># 一组实例化输入</span></span><br><span class="line">                  onnx_file_name,   <span class="comment"># 文件保存路径/名称</span></span><br><span class="line">                  export_params=<span class="literal">True</span>,        <span class="comment">#  如果指定为True或默认, 参数也会被导出. 如果你要导出一个没训练过的就设为 False.</span></span><br><span class="line">                  opset_version=<span class="number">12</span>,          <span class="comment"># ONNX 算子集的版本，当前已更新到15</span></span><br><span class="line">                  do_constant_folding=<span class="literal">True</span>,  <span class="comment"># 是否执行常量折叠优化</span></span><br><span class="line">                  input_names = [<span class="string">&#x27;input&#x27;</span>],   <span class="comment"># 输入模型的张量的名称</span></span><br><span class="line">                  output_names = [<span class="string">&#x27;output&#x27;</span>], <span class="comment"># 输出模型的张量的名称</span></span><br><span class="line">                  <span class="comment"># dynamic_axes将batch_size的维度指定为动态，</span></span><br><span class="line">                  <span class="comment"># 后续进行推理的数据可以与导出的dummy_input的batch_size不同</span></span><br><span class="line">                  dynamic_axes=&#123;<span class="string">&#x27;input&#x27;</span> : &#123;<span class="number">0</span> : <span class="string">&#x27;batch_size&#x27;</span>&#125;,</span><br><span class="line">                                <span class="string">&#x27;output&#x27;</span> : &#123;<span class="number">0</span> : <span class="string">&#x27;batch_size&#x27;</span>&#125;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>转换后的onnx文件名为  ‘model.onnx’ </p>
<h2 id="2-将-ONNX-模型导入到-TensorRT"><a href="#2-将-ONNX-模型导入到-TensorRT" class="headerlink" title="2 将 ONNX 模型导入到 TensorRT"></a>2 将 ONNX 模型导入到 TensorRT</h2><p>首先，我们要对tensorRT进行一些初始化设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorrt <span class="keyword">as</span> trt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建日志，级别为WARNING</span></span><br><span class="line">logger = trt.Logger(trt.Logger.WARNING)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以继承ILogger复写logger</span></span><br><span class="line"><span class="comment"># class MyLogger(trt.ILogger):</span></span><br><span class="line"><span class="comment">#     def __init__(self):</span></span><br><span class="line"><span class="comment">#        trt.ILogger.__init__(self)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     def log(self, severity, msg):</span></span><br><span class="line"><span class="comment">#         pass # Your custom logging implementation here</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># logger = MyLogger()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据logger创建builder</span></span><br><span class="line">builder = trt.Builder(logger)</span><br><span class="line"><span class="comment"># bulider的加速方法：https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html#opt-builder-perf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义网络</span></span><br><span class="line">network = builder.create_network(<span class="number">1</span> &lt;&lt; <span class="built_in">int</span>(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH))</span><br><span class="line"><span class="comment"># 详细文档：https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html#explicit-implicit-batch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载onnx模型</span></span><br><span class="line">parser = trt.OnnxParser(network, logger)</span><br><span class="line">success = parser.parse_from_file(<span class="string">&#x27;model.onnx&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(success)</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(parser.num_errors):</span><br><span class="line">    <span class="built_in">print</span>(parser.get_error(idx))</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># Error handling code here</span></span><br></pre></td></tr></table></figure>
<h2 id="3-应用优化并生成引擎"><a href="#3-应用优化并生成引擎" class="headerlink" title="3 应用优化并生成引擎"></a>3 应用优化并生成引擎</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">config = builder.create_builder_config()</span><br><span class="line">profile = builder.create_optimization_profile()</span><br><span class="line">profile.set_shape(<span class="string">&quot;input&quot;</span>, (<span class="number">1</span>, <span class="number">3</span>, <span class="number">64</span>,<span class="number">17</span>,<span class="number">1</span>), (<span class="number">8</span>, <span class="number">3</span>, <span class="number">64</span>,<span class="number">17</span>,<span class="number">1</span>), (<span class="number">16</span>, <span class="number">3</span>, <span class="number">64</span>,<span class="number">17</span>,<span class="number">1</span>))</span><br><span class="line">config.add_optimization_profile(profile)</span><br><span class="line">config.set_memory_pool_limit(trt.MemoryPoolType.WORKSPACE, <span class="number">1</span> &lt;&lt; <span class="number">31</span>) <span class="comment"># 1 MiB</span></span><br><span class="line">builder.build_engine(network, config)</span><br><span class="line">serialized_engine = builder.build_serialized_network(network, config)</span><br><span class="line"><span class="built_in">print</span>(serialized_engine)</span><br><span class="line"><span class="comment"># 保存引擎，引擎不能在不同的设备和版本上共享</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sample.engine&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(serialized_engine)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 加载引擎</span></span><br><span class="line">runtime = trt.Runtime(logger)</span><br><span class="line"><span class="comment"># 从加载流程反序列化引擎</span></span><br><span class="line">engine = runtime.deserialize_cuda_engine(serialized_engine)</span><br><span class="line"><span class="comment"># 从文件反序列化引擎</span></span><br><span class="line"><span class="comment"># with open(“sample.engine”, “rb”) as f:</span></span><br><span class="line"><span class="comment">#     serialized_engine = f.read()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建上下文管理器</span></span><br><span class="line">context = engine.create_execution_context()</span><br></pre></td></tr></table></figure>
<p>注意这里可能会有类似于”Could not find any implementation for node {ForeignNode[onnx::Add_1836…/l1/gcn1/relu/Relu]}.”的报错，这时候注意扩大<code>config.set_memory_pool_limit(trt.MemoryPoolType.WORKSPACE, 1 &lt;&lt; 31) # 1 MiB</code>中的内存空间。</p>
<h2 id="4-开始推理"><a href="#4-开始推理" class="headerlink" title="4 开始推理"></a>4 开始推理</h2><h3 id="4-1-读取数据"><a href="#4-1-读取数据" class="headerlink" title="4.1 读取数据"></a>4.1 读取数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 读取数据，数据处理为可以和网络结构输入对应起来的的shape，数据可增加预处理</span></span><br><span class="line"><span class="keyword">from</span> feeders.feeder_gym <span class="keyword">import</span> Feeder</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line">feeder=Feeder(data_path=<span class="string">&#x27;/share/gym/gym_train.pkl&#x27;</span>,</span><br><span class="line">              label_path=<span class="string">&#x27;/share/gym/gym_train.pkl&#x27;</span>)</span><br><span class="line">dataloader = DataLoader(feeder, batch_size=<span class="number">4</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>,</span><br><span class="line">                        collate_fn=<span class="literal">None</span>, pin_memory=<span class="literal">False</span>, drop_last=<span class="literal">False</span>, timeout=<span class="number">0</span>, worker_init_fn=<span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(<span class="built_in">iter</span>(dataloader)))</span><br><span class="line">image=feeder[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">image = np.expand_dims(image, <span class="number">0</span>)  <span class="comment"># Add batch dimension.</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-分配内存空间"><a href="#4-2-分配内存空间" class="headerlink" title="4.2 分配内存空间"></a>4.2 分配内存空间</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">context.set_binding_shape(<span class="number">0</span>, image.shape)</span><br><span class="line">d_input = cuda.mem_alloc(image.nbytes)  <span class="comment"># 分配输入的内存。</span></span><br><span class="line"></span><br><span class="line">output_shape = context.get_binding_shape(<span class="number">1</span>)</span><br><span class="line">buffer = np.empty(output_shape, dtype=np.float32)</span><br><span class="line">d_output = cuda.mem_alloc(buffer.nbytes)  <span class="comment"># 分配输出内存。</span></span><br><span class="line">cuda.memcpy_htod(d_input, image)</span><br><span class="line">bindings = [d_input, d_output]</span><br></pre></td></tr></table></figure>
<h3 id="4-3-进行推理，并将结果从gpu拷贝到cpu。"><a href="#4-3-进行推理，并将结果从gpu拷贝到cpu。" class="headerlink" title="4.3 进行推理，并将结果从gpu拷贝到cpu。"></a>4.3 进行推理，并将结果从gpu拷贝到cpu。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">context.execute_v2(bindings)  # 可异步和同步</span><br><span class="line">cuda.memcpy_dtoh(buffer, d_output)</span><br><span class="line">output = buffer.reshape(output_shape)</span><br><span class="line">print(output.shape)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模型部署优化</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>git基本用法</title>
    <url>/2023/03/06/git/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shellsudo apt-get install git</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git config --global user.email dingyn@djinni.club</span><br><span class="line">git config --global user.name dingyn</span><br><span class="line">git add readme.txt</span><br><span class="line">git rm text.txt</span><br><span class="line">git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p>
<p><code>git status</code>查看状态：</p>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销</p>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p>
<p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
<h2 id="git-服务器"><a href="#git-服务器" class="headerlink" title="git 服务器"></a>git 服务器</h2><p>在<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416">远程仓库</a>一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。</p>
<p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p>
<p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的<code>apt</code>命令就可以完成安装。</p>
<p>假设你已经有<code>sudo</code>权限的用户账号，下面，正式开始安装。</p>
<p>第一步，安装<code>git</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure>
<p>第二步，创建一个<code>git</code>用户，用来运行<code>git</code>服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo adduser git</span><br></pre></td></tr></table></figure>
<p>第三步，创建证书登录：</p>
<p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p>
<p>第四步，初始化Git仓库：</p>
<p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure>
<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure>
<p>第五步，禁用shell登录：</p>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure>
<p>这样，<code>git</code>用户可以正常通过ssh使用git，但无法登录shell，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出。</p>
<p>第六步，克隆远程仓库：</p>
<p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@server:/srv/sample.git</span><br><span class="line">Cloning into &#x27;sample&#x27;...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure>
<p>剩下的推送就简单了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>python优先队列</title>
    <url>/2023/03/06/priorty-queue/</url>
    <content><![CDATA[<blockquote>
<p>python自定义优先队列模版</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">My_PriorityQueue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._queue = []</span><br><span class="line">        self._index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, item, priority</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        队列由 (priority, index, item) 形式组成</span></span><br><span class="line"><span class="string">        priority 优先弹出优先级最小的值，即对于最大堆应该是-priority，最小堆是priority</span></span><br><span class="line"><span class="string">        index 是为了当两个对象的优先级一致时，按照插入顺序排列</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        heapq.heappush(self._queue, (-priority, self._index, item))</span><br><span class="line">        self._index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        弹出优先级最高的对象</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(self._queue)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">qsize</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._queue)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="keyword">not</span> self._queue <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._queue[<span class="number">0</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Min_PriorityQueue</span>(<span class="title class_ inherited__">My_PriorityQueue</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, item, priority</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        队列由 (priority, index, item) 形式组成</span></span><br><span class="line"><span class="string">        priority 优先弹出优先级最小的值，即对于最大堆应该是-priority，最小堆是priority</span></span><br><span class="line"><span class="string">        index 是为了当两个对象的优先级一致时，按照插入顺序排列</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        heapq.heappush(self._queue, (priority, self._index, item))</span><br><span class="line">        self._index += <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>kaggle动作检测挑战铜牌：nfl player contact detection 2023</title>
    <url>/2023/03/03/kaggle-nfl-player-contact-detection/</url>
    <content><![CDATA[<blockquote>
<p>The solution of the 87th, bronze medal, top 10%.</p>
</blockquote>
<p>代码链接：<a href="https://github.com/dingyn-Reno/kaggle_nfl_player_contact_detection">https://github.com/dingyn-Reno/kaggle_nfl_player_contact_detection</a></p>
<p>数据链接：<a href="https://www.kaggle.com/datasets/dyn201885095/testdata/download?datasetVersionNumber=24">https://www.kaggle.com/datasets/dyn201885095/testdata/download?datasetVersionNumber=24</a></p>
<p>提交代码：<a href="https://www.kaggle.com/code/yefawu/nfl-3in1?scriptVersionId=120272348">https://www.kaggle.com/code/yefawu/nfl-3in1?scriptVersionId=120272348</a></p>
<p>英文页面：<a href="https://github.com/dingyn-Reno/kaggle_nfl_player_contact_detection">https://github.com/dingyn-Reno/kaggle_nfl_player_contact_detection</a></p>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py --config config/config_for_train.yaml --device 0</span><br><span class="line">python main.py --config config/config.yaml --device 0</span><br></pre></td></tr></table></figure>
<h2 id="启动tensorboard"><a href="#启动tensorboard" class="headerlink" title="启动tensorboard"></a>启动tensorboard</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> NFL</span><br><span class="line">tensorboard --logdir=work_dir/nfl5/runs --bind_all</span><br></pre></td></tr></table></figure>
<h2 id="训练和测试"><a href="#训练和测试" class="headerlink" title="训练和测试"></a>训练和测试</h2><p>test:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py --config config/config.yaml --phase <span class="built_in">test</span> --save-score True --device 0 --weights ?</span><br></pre></td></tr></table></figure><br>train:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py --config ? --device </span><br></pre></td></tr></table></figure></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="第一步：特征工程"><a href="#第一步：特征工程" class="headerlink" title="第一步：特征工程"></a>第一步：特征工程</h3><ul>
<li>将测试的label根据提交样例的列表扩充到训练label的维度。</li>
<li>根据头盔传感器的数据，截取部分帧</li>
<li>处理表格数据</li>
<li>根据图像的定位坐标框截取图像</li>
<li>对图像进行特征增强处理</li>
</ul>
<h3 id="第二步：模型选择"><a href="#第二步：模型选择" class="headerlink" title="第二步：模型选择"></a>第二步：模型选择</h3><p>我们使用了0.5<em>resnet50+0.5</em>mobilenet_v3的模型融合方案(0.701)以及0.4<em>resnet50+0.4</em>mobilenet_v3+0.2*resnext的模型融合方案(0.701)。</p>
<p>以下模型我们进行了测试但最终没有选用：swin transformer,vit,regnety,efficientnet_b4,hrnet</p>
<p>以下模型被其他队伍使用但我们没有用：resnet3D，xgboost，efficientnet_v2</p>
<h3 id="第三步：TTA"><a href="#第三步：TTA" class="headerlink" title="第三步：TTA"></a>第三步：TTA</h3><p>我们使用了中值模糊和水平翻转两种TTA策略。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为我们的第一次kaggle比赛，拿到铜牌很值得鼓励，但是这次比赛对很多技巧和方法还不熟悉，比如一些trick的使用上，预训练参数的使用上，以及一些调优策略等。</p>
]]></content>
      <categories>
        <category>kaggle</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习调优策略</title>
    <url>/2023/02/01/train/</url>
    <content><![CDATA[<blockquote>
<p>文章参考google算法工程师团队的意见，得出深度学习工程的一些经验技巧。文章讨论了很多问题，我们在这里只讨论训练代码的一些基本思想。</p>
</blockquote>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>选择一个常用的模型开始工作，或者选择一个和目标任务相近的模型开始工作。</p>
<p>对于模型的过拟合问题，可以立即增加正则化项进行下一次实验，不需调整优化器参数。</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><ul>
<li>开始时使用更简单的优化器，例如SGD with fixed momentum 或者 Adam with fixed params。</li>
<li>理论上，稀疏数据适合Adam系算法。</li>
<li>待==模型参数==稳定后，进行更进一步的选择：</li>
</ul>
<p>for SGD，尝试SGD with Nesterov variant</p>
<p>for Adam和NAdam：调优策略：先调学习率（10次实验左右），再调beta1，再调eps（10-25），最后调beta2（25+）</p>
<img src="/2023/02/01/train/1.png" class="" title="学习率与loss的关系">
<h2 id="batch-size"><a href="#batch-size" class="headerlink" title="batch size"></a>batch size</h2><p>优化器参数和正则化参数受batch影响较大，因此改变batch后，需要对其重新调优。</p>
<p>训练时，给batch_size一个适当的值即可。</p>
<h2 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h2><p>对于超参数，面向不同的工作目标，超参数可以分为科学参数，扰动参数和固定参数。</p>
<p>比如，优化模型层数时，模型层数是科学参数，学习率是扰动参数，而在损失函数已经确定时，损失函数应该是固定参数。</p>
<p>通常来说，优化器类别是科学参数，优化器参数是扰动参数</p>
<p>正则化技术是否使用是科学参数，而正则化率是扰动参数，如dropout</p>
<p>层数是科学超参数</p>
<p>因此，一种可以考虑的思路是，首先，设定一个基础的batch size和学习器（默认参数SGD or Adam），确定模型的激活函数和损失函数。然后，调节神经网络层数，包括隐藏层数等，同时调节SGD或Adam参数。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ map和set</title>
    <url>/2023/01/30/cpp-tem/</url>
    <content><![CDATA[<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h3><p>set是一种关联式容器，其特性如下：</p>
<ul>
<li>set以RBTree作为底层容器</li>
<li>所得元素的只有key没有value，value就是key</li>
<li>不允许出现键值重复</li>
<li>所有的元素都会被自动排序</li>
<li>不能通过迭代器来改变set的值，因为set的值就是键</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map和set一样是关联式容器，它们的底层容器都是红黑树，区别就在于map的值不作为键，键和值是分开的。它的特性如下：</p>
<ul>
<li>map以RBTree作为底层容器</li>
<li>所有元素都是键+值存在</li>
<li>不允许键重复</li>
<li>所有元素是通过键进行自动排序的</li>
<li>map的键是不能修改的，但是其键对应的值是可以修改的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//初始化set</span></span><br><span class="line">    set&lt;<span class="type">int</span>,less&lt;<span class="type">int</span>&gt;&gt; set1;</span><br><span class="line">    <span class="comment">//插入set</span></span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//遍历set</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=set1.<span class="built_in">begin</span>();i!=set1.<span class="built_in">end</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;*i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//擦除元素，参数也可以是迭代器或者迭代器范围</span></span><br><span class="line">    set1.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//查找元素数量</span></span><br><span class="line">    cout&lt;&lt;set1.<span class="built_in">count</span>(<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;set1.<span class="built_in">count</span>(<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//查找函数</span></span><br><span class="line">    <span class="keyword">auto</span> it=set1.<span class="built_in">find</span>(<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line"><span class="comment">/*output：</span></span><br><span class="line"><span class="comment">1 2 3 4 </span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用自定义的比较规则如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tk</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">tk</span>()&#123;</span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        k=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tk</span>(<span class="type">int</span> t,<span class="type">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t=t;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> tk&amp; i1) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;t&gt;i1.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> tk i1,<span class="type">const</span> tk i2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i1&gt;i2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化set</span></span><br><span class="line">    set&lt;tk,cmp&gt; set1;</span><br><span class="line">    <span class="comment">//插入set</span></span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="built_in">tk</span>(<span class="number">3</span>,<span class="number">1</span>));</span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="built_in">tk</span>(<span class="number">4</span>,<span class="number">1</span>));</span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="built_in">tk</span>(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">    set1.<span class="built_in">insert</span>(<span class="built_in">tk</span>(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//遍历set</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=set1.<span class="built_in">begin</span>();i!=set1.<span class="built_in">end</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;(*i).t&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 输入输出流</title>
    <url>/2023/01/30/cpp-iostream/</url>
    <content><![CDATA[<blockquote>
<p>C++的一个独门绝技是通过字节流的方式进行I/O，对于程序员来说，掌握常用的I/O操作是必要的功课。</p>
</blockquote>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>大部分流操作使用的头文件是iostream；</p>
<p>部分格式化操作的头文件是iomanip;</p>
<p>文件处理服务是fstream;</p>
<h2 id="字符I-O"><a href="#字符I-O" class="headerlink" title="字符I/O"></a>字符I/O</h2><p>使用cout.put()可以进行字符输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> t=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">//字符输出</span></span><br><span class="line">cout.<span class="built_in">put</span>(t)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//级联</span></span><br><span class="line">cout.<span class="built_in">put</span>(t).<span class="built_in">put</span>(t)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//output：</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//AA</span></span><br></pre></td></tr></table></figure>
<p>输入字符的函数有cin.get()和cin.getline(),在循环输入字符时，常通过EOF判断是否结束输入，在windows系统中，结束标志为ctrl+z,而linux和mac中为ctrl+d</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="type">char</span> t;</span><br><span class="line">    <span class="comment">//输入一个字符</span></span><br><span class="line">    cin.<span class="built_in">get</span>(t);</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环输入字符，直到终止</span></span><br><span class="line"><span class="comment">//    while((t=cin.get())!=EOF)&#123;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;t;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//输入数组</span></span><br><span class="line">    <span class="type">char</span> p[<span class="number">20</span>];</span><br><span class="line">    cin.<span class="built_in">get</span>(p,<span class="number">20</span>);</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//cin.get()的默认分隔符是enter，修改默认分隔符</span></span><br><span class="line">    cin.<span class="built_in">get</span>(p,<span class="number">20</span>,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h2 id="数字格式"><a href="#数字格式" class="headerlink" title="数字格式"></a>数字格式</h2><p>dec,oct,hex,以及setbase()用于修改数字的进制，showbase和noshowbase用于开关数字的进制前缀，uppercase和nouppercase可以开关前缀的大小写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="type">int</span> number=<span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;hex&lt;&lt;number&lt;&lt;oct&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;number&lt;&lt;dec&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;number&lt;&lt;<span class="built_in">setbase</span>(<span class="number">8</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;showbase;</span><br><span class="line">    cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;hex&lt;&lt;number&lt;&lt;oct&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;number&lt;&lt;dec&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;number&lt;&lt;<span class="built_in">setbase</span>(<span class="number">8</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;noshowbase;</span><br><span class="line">    cout&lt;&lt;number&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;hex&lt;&lt;number&lt;&lt;oct&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;number&lt;&lt;dec&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;number&lt;&lt;<span class="built_in">setbase</span>(<span class="number">8</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * output:</span></span><br><span class="line"><span class="comment">18 12 22 18 22</span></span><br><span class="line"><span class="comment">022 0x12 022 18 022</span></span><br><span class="line"><span class="comment">22 12 22 18 22</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<p>precision()用于表示浮点精度；showpoint强制显示小数后面的0;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//默认的浮点精度为6</span></span><br><span class="line">    <span class="type">double</span> number=<span class="number">1.123456789</span>;</span><br><span class="line">    cout&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        cout.<span class="built_in">precision</span>(i);</span><br><span class="line">        cout&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    number=<span class="number">1.12000</span>;</span><br><span class="line">    cout&lt;&lt;showpoint&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//output:</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">1.12346</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1.1</span></span><br><span class="line"><span class="comment">1.12</span></span><br><span class="line"><span class="comment">1.123</span></span><br><span class="line"><span class="comment">1.1235</span></span><br><span class="line"><span class="comment">1.12346</span></span><br><span class="line"><span class="comment">1.123457</span></span><br><span class="line"><span class="comment">1.1234568</span></span><br><span class="line"><span class="comment">1.12345679</span></span><br><span class="line"><span class="comment">1.12000000</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<p>scientific和fixed用于表示科学计数法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="type">double</span> num=<span class="number">1.23</span>;</span><br><span class="line">    cout&lt;&lt;scientific&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * output:</span></span><br><span class="line"><span class="comment">1.230000e+00</span></span><br><span class="line"><span class="comment">1.230000</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<h2 id="宽度与对齐"><a href="#宽度与对齐" class="headerlink" title="宽度与对齐"></a>宽度与对齐</h2><p>width可以为输入和输出限定宽度，这个用的不多，直接上个图例了</p>
<p><img src="/Users/djinniding/Library/Application Support/typora-user-images/image-20230114204331522.png" alt="image-20230114204331522"></p>
<p>setw()用于指定输出宽度；right,left表示左右对齐，internel对于数字将符号显示到左边，数值显示到右边；cout.fill()和流操作setfill ()指定对齐域的填充字符；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="type">double</span> num=<span class="number">1.23</span>;</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">8</span>)&lt;&lt;right&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">8</span>)&lt;&lt;left&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">8</span>)&lt;&lt;internal&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">8</span>)&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>)&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * output:</span></span><br><span class="line"><span class="comment">      1.23</span></span><br><span class="line"><span class="comment">    1.23</span></span><br><span class="line"><span class="comment">1.23    </span></span><br><span class="line"><span class="comment">    1.23</span></span><br><span class="line"><span class="comment">****1.23</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<h2 id="bool的形式"><a href="#bool的形式" class="headerlink" title="bool的形式"></a>bool的形式</h2><p>默认的bool形式为0或1，使用boolalpha可以改为false和true显示，使用noboolaplha可以改回。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="type">bool</span> a= <span class="literal">true</span>;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;boolalpha&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;noboolalpha&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * output:</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<h2 id="流状态"><a href="#流状态" class="headerlink" title="流状态"></a>流状态</h2><p>cout.flags表示输出流的格式状态，我们可以使用cout.flags()查看当前的流状态，也可以用cout.flags(originalFormat)还原流状态。</p>
]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>一个基于pytorch的深度学习训练代码框架</title>
    <url>/2022/11/11/modeldemo/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>pytorch是笔者当前主要使用的深度学习框架，但每次搭建训练代码时，笔者都要陷入繁琐的代码架构编写和配置参数文件的痛苦中。因此，笔者决定设计一个稳定的神经网络的训练框架，这样只要进行一些必要的配置，就可以开始愉快的炼丹了。</p>
<p>本文主要介绍代码的每一部分的功能，对于只想使用本项目的，可直接跳转项目地址，浏览代码的使用说明：<a href="https://github.com/dingyn-Reno/torch-model-demo">https://github.com/dingyn-Reno/torch-model-demo</a></p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-conig 存放配置文件</span><br><span class="line">--config.yaml</span><br><span class="line">-feeder 存放数据加载和处理文件</span><br><span class="line">--feeder.py</span><br><span class="line">-model 存放模型</span><br><span class="line">-torchlight torch的工具包</span><br><span class="line">-main.py 主函数</span><br><span class="line">-send_mail.py 邮件发送函数</span><br></pre></td></tr></table></figure>
<h2 id="训练前准备"><a href="#训练前准备" class="headerlink" title="训练前准备"></a>训练前准备</h2><p>在main.py里，我们要完成训练前的准备代码以及训练和测试的流程代码。</p>
<h3 id="导入必要的包"><a href="#导入必要的包" class="headerlink" title="导入必要的包"></a>导入必要的包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> torchlight <span class="keyword">import</span> DictAction</span><br><span class="line"><span class="comment"># torch</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.backends.cudnn <span class="keyword">as</span> cudnn</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">from</span> tensorboardX <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> resource</span><br><span class="line"><span class="keyword">from</span> send_mail <span class="keyword">import</span> send</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br></pre></td></tr></table></figure>
<h3 id="设置资源管理"><a href="#设置资源管理" class="headerlink" title="设置资源管理"></a>设置资源管理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rlimit = resource.getrlimit(resource.RLIMIT_NOFILE)</span><br><span class="line">resource.setrlimit(resource.RLIMIT_NOFILE, (<span class="number">2048</span>, rlimit[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="设置初始化种子"><a href="#设置初始化种子" class="headerlink" title="设置初始化种子"></a>设置初始化种子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_seed</span>(<span class="params">seed</span>):</span><br><span class="line">    torch.cuda.manual_seed_all(seed)</span><br><span class="line">    torch.manual_seed(seed)</span><br><span class="line">    np.random.seed(seed)</span><br><span class="line">    random.seed(seed)</span><br><span class="line">    <span class="comment"># torch.backends.cudnn.enabled = False</span></span><br><span class="line">    torch.backends.cudnn.deterministic = <span class="literal">True</span></span><br><span class="line">    torch.backends.cudnn.benchmark = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="设置导入类的函数"><a href="#设置导入类的函数" class="headerlink" title="设置导入类的函数"></a>设置导入类的函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">import_class</span>(<span class="params">import_str</span>):</span><br><span class="line">    mod_str, _sep, class_str = import_str.rpartition(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="built_in">__import__</span>(mod_str)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(sys.modules[mod_str], class_str)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">raise</span> ImportError(<span class="string">&#x27;Class %s cannot be found (%s)&#x27;</span> % (class_str, traceback.format_exception(*sys.exc_info())))</span><br></pre></td></tr></table></figure>
<h3 id="string转bool函数"><a href="#string转bool函数" class="headerlink" title="string转bool函数"></a>string转bool函数</h3><p>用于处理bool类参数的输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">str2bool</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">if</span> v.lower() <span class="keyword">in</span> (<span class="string">&#x27;yes&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;1&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> v.lower() <span class="keyword">in</span> (<span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;false&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> argparse.ArgumentTypeError(<span class="string">&#x27;Unsupported value encountered.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="读取默认参数"><a href="#读取默认参数" class="headerlink" title="读取默认参数"></a>读取默认参数</h3><p>参数优先级：命令行&gt;配置文件&gt;默认</p>
<p>不是所有的都有用，也可以视情况添加新的函数，值得注意的是train_feeder_args、test_feeder_args、model_args这三个函数，通过dictaction方法传入了一组参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_parser</span>():</span><br><span class="line">    <span class="comment"># parameter priority: command line &gt; config &gt; default</span></span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">&#x27;Spatial Temporal Graph Convolution Network&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--work-dir&#x27;</span>,</span><br><span class="line">        default=<span class="string">&#x27;./work_dir/temp&#x27;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the work folder for storing results&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-model_saved_name&#x27;</span>, default=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--config&#x27;</span>,</span><br><span class="line">        default=<span class="string">&#x27;./config/nturgbd-cross-view/test_bone.yaml&#x27;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;path to the configuration file&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># processor</span></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--phase&#x27;</span>, default=<span class="string">&#x27;train&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;must be train or test&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--save-score&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=str2bool,</span><br><span class="line">        default=<span class="literal">False</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;if ture, the classification score will be stored&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># visulize and debug</span></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--seed&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>, <span class="built_in">help</span>=<span class="string">&#x27;random seed for pytorch&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--log-interval&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">100</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the interval for printing messages (#iteration)&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--save-interval&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">1</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the interval for storing models (#iteration)&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--save-epoch&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">30</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the start epoch to save model (#iteration)&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--eval-interval&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">5</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the interval for evaluating models (#iteration)&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--print-log&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=str2bool,</span><br><span class="line">        default=<span class="literal">True</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;print logging or not&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--show-topk&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=[<span class="number">1</span>, <span class="number">5</span>],</span><br><span class="line">        nargs=<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;which Top K accuracy will be shown&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># feeder</span></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--feeder&#x27;</span>, default=<span class="string">&#x27;feeder.feeder&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;data loader will be used&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--num-worker&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">16</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the number of worker for data loader&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--train-feeder-args&#x27;</span>,</span><br><span class="line">        action=DictAction,</span><br><span class="line">        default=<span class="built_in">dict</span>(),</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the arguments of data loader for training&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--test-feeder-args&#x27;</span>,</span><br><span class="line">        action=DictAction,</span><br><span class="line">        default=<span class="built_in">dict</span>(),</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the arguments of data loader for test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># model</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--model&#x27;</span>, default=<span class="literal">None</span>, <span class="built_in">help</span>=<span class="string">&#x27;the model will be used&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--model-args&#x27;</span>,</span><br><span class="line">        action=DictAction,</span><br><span class="line">        default=<span class="built_in">dict</span>(),</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the arguments of model&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--weights&#x27;</span>,</span><br><span class="line">        default=<span class="literal">None</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the weights for network initialization&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--ignore-weights&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        default=[],</span><br><span class="line">        nargs=<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the name of weights which will be ignored in the initialization&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># optim</span></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--base-lr&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.01</span>, <span class="built_in">help</span>=<span class="string">&#x27;initial learning rate&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--step&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=[<span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>],</span><br><span class="line">        nargs=<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the epoch where optimizer reduce the learning rate&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--device&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">0</span>,</span><br><span class="line">        nargs=<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;the indexes of GPUs for training or testing&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--optimizer&#x27;</span>, default=<span class="string">&#x27;SGD&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;type of optimizer&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--nesterov&#x27;</span>, <span class="built_in">type</span>=str2bool, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;use nesterov or not&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--batch-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">256</span>, <span class="built_in">help</span>=<span class="string">&#x27;training batch size&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--test-batch-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">256</span>, <span class="built_in">help</span>=<span class="string">&#x27;test batch size&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--start-epoch&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">0</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;start training from which epoch&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--num-epoch&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">80</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;stop training in which epoch&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--weight-decay&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">float</span>,</span><br><span class="line">        default=<span class="number">0.0005</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;weight decay for optimizer&#x27;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&#x27;--lr-decay-rate&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">float</span>,</span><br><span class="line">        default=<span class="number">0.1</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;decay rate for learning rate&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--warm_up_epoch&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">0</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--classes&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> parser</span><br></pre></td></tr></table></figure>
<h2 id="训练代码"><a href="#训练代码" class="headerlink" title="训练代码"></a>训练代码</h2><p>接着，我们在main.py里编写训练/测试代码，首先定义class Processor，我们的代码将在这里完成。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arg</span>):</span><br><span class="line">    self.arg = arg</span><br><span class="line">    self.save_arg()</span><br><span class="line">    <span class="keyword">if</span> arg.phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arg.train_feeder_args[<span class="string">&#x27;debug&#x27;</span>]:</span><br><span class="line">            arg.model_saved_name = os.path.join(arg.work_dir, <span class="string">&#x27;runs&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> os.path.isdir(arg.model_saved_name):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;log_dir: &#x27;</span>, arg.model_saved_name, <span class="string">&#x27;already exist&#x27;</span>)</span><br><span class="line">                answer = <span class="built_in">input</span>(<span class="string">&#x27;delete it? y/n:&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> answer == <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">                    shutil.rmtree(arg.model_saved_name)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;Dir removed: &#x27;</span>, arg.model_saved_name)</span><br><span class="line">                    <span class="built_in">input</span>(<span class="string">&#x27;Refresh the website of tensorboard by pressing any keys&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;Dir not removed: &#x27;</span>, arg.model_saved_name)</span><br><span class="line">            self.train_writer = SummaryWriter(os.path.join(arg.model_saved_name, <span class="string">&#x27;train&#x27;</span>), <span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">            self.val_writer = SummaryWriter(os.path.join(arg.model_saved_name, <span class="string">&#x27;val&#x27;</span>), <span class="string">&#x27;val&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.train_writer = self.val_writer = SummaryWriter(os.path.join(arg.model_saved_name, <span class="string">&#x27;test&#x27;</span>), <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    self.global_step = <span class="number">0</span></span><br><span class="line">    self.load_model()</span><br><span class="line">    <span class="keyword">if</span> self.arg.phase == <span class="string">&#x27;model_size&#x27;</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.load_optimizer()</span><br><span class="line">        self.load_data()</span><br><span class="line">    self.lr = self.arg.base_lr</span><br><span class="line">    self.best_acc = <span class="number">0</span></span><br><span class="line">    self.best_acc_epoch = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    self.model = self.model.cuda(self.output_device)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(self.arg.device) <span class="keyword">is</span> <span class="built_in">list</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.arg.device) &gt; <span class="number">1</span>:</span><br><span class="line">            self.model = nn.DataParallel(</span><br><span class="line">                self.model,</span><br><span class="line">                device_ids=self.arg.device,</span><br><span class="line">                output_device=self.output_device)</span><br></pre></td></tr></table></figure>
<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 数据读取部分，编写feeder文件夹中的数据处理代码，并修改dataset参数设置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_data</span>(<span class="params">self</span>):</span><br><span class="line">        Feeder = import_class(self.arg.feeder)</span><br><span class="line">        self.data_loader = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">if</span> self.arg.phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            self.data_loader[<span class="string">&#x27;train&#x27;</span>] = torch.utils.data.DataLoader(</span><br><span class="line">                dataset=Feeder(**self.arg.train_feeder_args),</span><br><span class="line">                batch_size=self.arg.batch_size,</span><br><span class="line">                shuffle=<span class="literal">True</span>,</span><br><span class="line">                num_workers=self.arg.num_worker,</span><br><span class="line">                drop_last=<span class="literal">True</span>,</span><br><span class="line">                worker_init_fn=init_seed)</span><br><span class="line">        self.data_loader[<span class="string">&#x27;test&#x27;</span>] = torch.utils.data.DataLoader(</span><br><span class="line">            dataset=Feeder(**self.arg.test_feeder_args),</span><br><span class="line">            batch_size=self.arg.test_batch_size,</span><br><span class="line">            shuffle=<span class="literal">False</span>,</span><br><span class="line">            num_workers=self.arg.num_worker,</span><br><span class="line">            drop_last=<span class="literal">False</span>,</span><br><span class="line">            worker_init_fn=init_seed)</span><br></pre></td></tr></table></figure>
<h3 id="读取模型"><a href="#读取模型" class="headerlink" title="读取模型"></a>读取模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2 模型读取部分，编写model文件夹中的模型代码，修改Model函数参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_model</span>(<span class="params">self</span>):</span><br><span class="line">        output_device = self.arg.device[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">type</span>(self.arg.device) <span class="keyword">is</span> <span class="built_in">list</span> <span class="keyword">else</span> self.arg.device</span><br><span class="line">        self.output_device = output_device</span><br><span class="line">        Model = import_class(self.arg.model)</span><br><span class="line">        shutil.copy2(inspect.getfile(Model), self.arg.work_dir)</span><br><span class="line">        <span class="built_in">print</span>(Model)</span><br><span class="line">        <span class="comment"># 模型参数配置位置</span></span><br><span class="line">        self.model = Model(**self.arg.model_args)</span><br><span class="line">        <span class="built_in">print</span>(self.model)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.arg.weights:</span><br><span class="line">            self.global_step = <span class="built_in">int</span>(arg.weights[:-<span class="number">3</span>].split(<span class="string">&#x27;-&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">            self.print_log(<span class="string">&#x27;Load weights from &#123;&#125;.&#x27;</span>.<span class="built_in">format</span>(self.arg.weights))</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;.pkl&#x27;</span> <span class="keyword">in</span> self.arg.weights:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(self.arg.weights, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    weights = pickle.load(f)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                weights = torch.load(self.arg.weights)</span><br><span class="line"></span><br><span class="line">            weights = OrderedDict([[k.split(<span class="string">&#x27;module.&#x27;</span>)[-<span class="number">1</span>], v.cuda(output_device)] <span class="keyword">for</span> k, v <span class="keyword">in</span> weights.items()])</span><br><span class="line"></span><br><span class="line">            keys = <span class="built_in">list</span>(weights.keys())</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> self.arg.ignore_weights:</span><br><span class="line">                <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">                    <span class="keyword">if</span> w <span class="keyword">in</span> key:</span><br><span class="line">                        <span class="keyword">if</span> weights.pop(key, <span class="literal">None</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                            self.print_log(<span class="string">&#x27;Sucessfully Remove Weights: &#123;&#125;.&#x27;</span>.<span class="built_in">format</span>(key))</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            self.print_log(<span class="string">&#x27;Can Not Remove Weights: &#123;&#125;.&#x27;</span>.<span class="built_in">format</span>(key))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.model.load_state_dict(weights)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                state = self.model.state_dict()</span><br><span class="line">                diff = <span class="built_in">list</span>(<span class="built_in">set</span>(state.keys()).difference(<span class="built_in">set</span>(weights.keys())))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Can not find these weights:&#x27;</span>)</span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> diff:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;  &#x27;</span> + d)</span><br><span class="line">                state.update(weights)</span><br><span class="line">                self.model.load_state_dict(state)</span><br></pre></td></tr></table></figure>
<h3 id="配置优化器"><a href="#配置优化器" class="headerlink" title="配置优化器"></a>配置优化器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3 优化器配置，如果使用需要更新参数的loss，需要把loss置入损失函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_optimizer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.arg.optimizer == <span class="string">&#x27;SGD&#x27;</span>:</span><br><span class="line">            self.optimizer = optim.SGD(</span><br><span class="line">                self.model.parameters(),</span><br><span class="line">                lr=self.arg.base_lr,</span><br><span class="line">                momentum=<span class="number">0.9</span>,</span><br><span class="line">                nesterov=self.arg.nesterov,</span><br><span class="line">                weight_decay=self.arg.weight_decay)</span><br><span class="line">        <span class="keyword">elif</span> self.arg.optimizer == <span class="string">&#x27;Adam&#x27;</span>:</span><br><span class="line">            self.optimizer = optim.Adam(</span><br><span class="line">                self.model.parameters(),</span><br><span class="line">                lr=self.arg.base_lr,</span><br><span class="line">                weight_decay=self.arg.weight_decay)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError()</span><br><span class="line">        self.print_log(<span class="string">&#x27;using warm up, epoch: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.arg.warm_up_epoch))</span><br></pre></td></tr></table></figure>
<h3 id="保存参数"><a href="#保存参数" class="headerlink" title="保存参数"></a>保存参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_arg</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># save arg</span></span><br><span class="line">    arg_dict = <span class="built_in">vars</span>(self.arg)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(self.arg.work_dir):</span><br><span class="line">        os.makedirs(self.arg.work_dir)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;&#123;&#125;/config.yaml&#x27;</span>.<span class="built_in">format</span>(self.arg.work_dir), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">f&quot;# command line: <span class="subst">&#123;<span class="string">&#x27; &#x27;</span>.join(sys.argv)&#125;</span>\n\n&quot;</span>)</span><br><span class="line">        yaml.dump(arg_dict, f)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="学习率设定"><a href="#学习率设定" class="headerlink" title="学习率设定"></a>学习率设定</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">adjust_learning_rate</span>(<span class="params">self, epoch</span>):</span><br><span class="line">    <span class="keyword">if</span> self.arg.optimizer == <span class="string">&#x27;SGD&#x27;</span> <span class="keyword">or</span> self.arg.optimizer == <span class="string">&#x27;Adam&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> epoch &lt; self.arg.warm_up_epoch:</span><br><span class="line">            lr = self.arg.base_lr * (epoch + <span class="number">1</span>) / self.arg.warm_up_epoch</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lr = self.arg.base_lr * (</span><br><span class="line">                    self.arg.lr_decay_rate ** np.<span class="built_in">sum</span>(epoch &gt;= np.array(self.arg.step)))</span><br><span class="line">        <span class="keyword">for</span> param_group <span class="keyword">in</span> self.optimizer.param_groups:</span><br><span class="line">            param_group[<span class="string">&#x27;lr&#x27;</span>] = lr</span><br><span class="line">        <span class="keyword">return</span> lr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError()</span><br></pre></td></tr></table></figure>
<h3 id="打印时间"><a href="#打印时间" class="headerlink" title="打印时间"></a>打印时间</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_time</span>(<span class="params">self</span>):</span><br><span class="line">    localtime = time.asctime(time.localtime(time.time()))</span><br><span class="line">    self.print_log(<span class="string">&quot;Local current time :  &quot;</span> + localtime)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="print同时写入文件"><a href="#print同时写入文件" class="headerlink" title="print同时写入文件"></a>print同时写入文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_log</span>(<span class="params">self, <span class="built_in">str</span>, print_time=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">if</span> print_time:</span><br><span class="line">        localtime = time.asctime(time.localtime(time.time()))</span><br><span class="line">        <span class="built_in">str</span> = <span class="string">&quot;[ &quot;</span> + localtime + <span class="string">&#x27; ] &#x27;</span> + <span class="built_in">str</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">if</span> self.arg.print_log:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;&#123;&#125;/log.txt&#x27;</span>.<span class="built_in">format</span>(self.arg.work_dir), <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>, file=f)</span><br></pre></td></tr></table></figure>
<h3 id="记录时间"><a href="#记录时间" class="headerlink" title="记录时间"></a>记录时间</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">record_time</span>(<span class="params">self</span>):</span><br><span class="line">    self.cur_time = time.time()</span><br><span class="line">    <span class="keyword">return</span> self.cur_time</span><br></pre></td></tr></table></figure>
<h3 id="计算分段时间"><a href="#计算分段时间" class="headerlink" title="计算分段时间"></a>计算分段时间</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">split_time</span>(<span class="params">self</span>):</span><br><span class="line">    split_time = time.time() - self.cur_time</span><br><span class="line">    self.record_time()</span><br><span class="line">    <span class="keyword">return</span> split_time</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="设置损失函数"><a href="#设置损失函数" class="headerlink" title="设置损失函数"></a>设置损失函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置损失函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_loss</span>(<span class="params">self</span>):</span><br><span class="line">    self.loss = nn.CrossEntropyLoss().cuda(self.output_device)</span><br></pre></td></tr></table></figure>
<h3 id="计算准确率"><a href="#计算准确率" class="headerlink" title="计算准确率"></a>计算准确率</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_acc</span>(<span class="params">self,output,label</span>):</span><br><span class="line">    value, predict_label = torch.<span class="built_in">max</span>(output.data, <span class="number">1</span>)</span><br><span class="line">    acc = torch.mean((predict_label == label.data).<span class="built_in">float</span>())</span><br><span class="line">    <span class="keyword">return</span> acc</span><br></pre></td></tr></table></figure>
<h3 id="启动训练"><a href="#启动训练" class="headerlink" title="启动训练"></a>启动训练</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.arg.phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">        self.print_log(<span class="string">&#x27;Parameters:\n&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">vars</span>(self.arg))))</span><br><span class="line">        self.global_step = self.arg.start_epoch * <span class="built_in">len</span>(self.data_loader[<span class="string">&#x27;train&#x27;</span>]) / self.arg.batch_size</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">count_parameters</span>(<span class="params">model</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(p.numel() <span class="keyword">for</span> p <span class="keyword">in</span> model.parameters() <span class="keyword">if</span> p.requires_grad)</span><br><span class="line">        self.print_log(<span class="string">f&#x27;# Parameters: <span class="subst">&#123;count_parameters(self.model)&#125;</span>&#x27;</span>)</span><br><span class="line">        self.set_loss()</span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(self.arg.start_epoch, self.arg.num_epoch):</span><br><span class="line">            save_model = (((epoch + <span class="number">1</span>) % self.arg.save_interval == <span class="number">0</span>) <span class="keyword">or</span> (</span><br><span class="line">                    epoch + <span class="number">1</span> == self.arg.num_epoch)) <span class="keyword">and</span> (epoch+<span class="number">1</span>) &gt; self.arg.save_epoch</span><br><span class="line"></span><br><span class="line">            self.train(epoch, save_model=save_model)</span><br><span class="line"></span><br><span class="line">            self.<span class="built_in">eval</span>(epoch, save_score=self.arg.save_score, loader_name=[<span class="string">&#x27;test&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># test the best model</span></span><br><span class="line">        weights_path = glob.glob(os.path.join(self.arg.work_dir, <span class="string">&#x27;runs-&#x27;</span>+<span class="built_in">str</span>(self.best_acc_epoch)+<span class="string">&#x27;*&#x27;</span>))[<span class="number">0</span>]</span><br><span class="line">        weights = torch.load(weights_path)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(self.arg.device) <span class="keyword">is</span> <span class="built_in">list</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.arg.device) &gt; <span class="number">1</span>:</span><br><span class="line">                weights = OrderedDict([[<span class="string">&#x27;module.&#x27;</span>+k, v.cuda(self.output_device)] <span class="keyword">for</span> k, v <span class="keyword">in</span> weights.items()])</span><br><span class="line">        self.model.load_state_dict(weights)</span><br><span class="line"></span><br><span class="line">        wf = weights_path.replace(<span class="string">&#x27;.pt&#x27;</span>, <span class="string">&#x27;_wrong.txt&#x27;</span>)</span><br><span class="line">        rf = weights_path.replace(<span class="string">&#x27;.pt&#x27;</span>, <span class="string">&#x27;_right.txt&#x27;</span>)</span><br><span class="line">        self.arg.print_log = <span class="literal">False</span></span><br><span class="line">        self.<span class="built_in">eval</span>(epoch=<span class="number">0</span>, save_score=<span class="literal">True</span>, loader_name=[<span class="string">&#x27;test&#x27;</span>], wrong_file=wf, result_file=rf)</span><br><span class="line">        self.arg.print_log = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        num_params = <span class="built_in">sum</span>(p.numel() <span class="keyword">for</span> p <span class="keyword">in</span> self.model.parameters() <span class="keyword">if</span> p.requires_grad)</span><br><span class="line">        self.print_log(<span class="string">f&#x27;Best accuracy: <span class="subst">&#123;self.best_acc&#125;</span>&#x27;</span>)</span><br><span class="line">        self.print_log(<span class="string">f&#x27;Epoch number: <span class="subst">&#123;self.best_acc_epoch&#125;</span>&#x27;</span>)</span><br><span class="line">        self.print_log(<span class="string">f&#x27;Model name: <span class="subst">&#123;self.arg.work_dir&#125;</span>&#x27;</span>)</span><br><span class="line">        self.print_log(<span class="string">f&#x27;Model total number of params: <span class="subst">&#123;num_params&#125;</span>&#x27;</span>)</span><br><span class="line">        self.print_log(<span class="string">f&#x27;Weight decay: <span class="subst">&#123;self.arg.weight_decay&#125;</span>&#x27;</span>)</span><br><span class="line">        self.print_log(<span class="string">f&#x27;Base LR: <span class="subst">&#123;self.arg.base_lr&#125;</span>&#x27;</span>)</span><br><span class="line">        self.print_log(<span class="string">f&#x27;Batch Size: <span class="subst">&#123;self.arg.batch_size&#125;</span>&#x27;</span>)</span><br><span class="line">        self.print_log(<span class="string">f&#x27;Test Batch Size: <span class="subst">&#123;self.arg.test_batch_size&#125;</span>&#x27;</span>)</span><br><span class="line">        self.print_log(<span class="string">f&#x27;seed: <span class="subst">&#123;self.arg.seed&#125;</span>&#x27;</span>)</span><br><span class="line">        body = <span class="string">&quot;你的模型已经跑完，精度为&#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.best_acc)</span><br><span class="line">        send(body)</span><br><span class="line">    <span class="keyword">elif</span> self.arg.phase == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">        wf = self.arg.weights.replace(<span class="string">&#x27;.pt&#x27;</span>, <span class="string">&#x27;_wrong.txt&#x27;</span>)</span><br><span class="line">        rf = self.arg.weights.replace(<span class="string">&#x27;.pt&#x27;</span>, <span class="string">&#x27;_right.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.arg.weights <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Please appoint --weights.&#x27;</span>)</span><br><span class="line">        self.arg.print_log = <span class="literal">False</span></span><br><span class="line">        self.print_log(<span class="string">&#x27;Model:   &#123;&#125;.&#x27;</span>.<span class="built_in">format</span>(self.arg.model))</span><br><span class="line">        self.print_log(<span class="string">&#x27;Weights: &#123;&#125;.&#x27;</span>.<span class="built_in">format</span>(self.arg.weights))</span><br><span class="line">        self.<span class="built_in">eval</span>(epoch=<span class="number">0</span>, save_score=self.arg.save_score, loader_name=[<span class="string">&#x27;test&#x27;</span>], wrong_file=wf, result_file=rf)</span><br><span class="line">        self.print_log(<span class="string">&#x27;Done.\n&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, epoch, save_model=<span class="literal">False</span></span>):</span><br><span class="line">    self.model.train()</span><br><span class="line">    self.print_log(<span class="string">&#x27;Training epoch: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>))</span><br><span class="line">    loader = self.data_loader[<span class="string">&#x27;train&#x27;</span>]</span><br><span class="line">    self.adjust_learning_rate(epoch)</span><br><span class="line">    loss_value = []</span><br><span class="line">    acc_value = []</span><br><span class="line">    self.train_writer.add_scalar(<span class="string">&#x27;epoch&#x27;</span>, epoch, self.global_step)</span><br><span class="line">    self.record_time()</span><br><span class="line">    timer = <span class="built_in">dict</span>(dataloader=<span class="number">0.001</span>, model=<span class="number">0.001</span>, statistics=<span class="number">0.001</span>)</span><br><span class="line">    process = tqdm(loader, ncols=<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, label, index) <span class="keyword">in</span> <span class="built_in">enumerate</span>(process):</span><br><span class="line">        self.global_step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            data = data.<span class="built_in">float</span>().cuda(self.output_device)</span><br><span class="line">            label = label.long().cuda(self.output_device)</span><br><span class="line">        timer[<span class="string">&#x27;dataloader&#x27;</span>] += self.split_time()</span><br><span class="line">        output = self.model(data)</span><br><span class="line">        loss = self.loss(output, label)</span><br><span class="line">        self.optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        self.optimizer.step()</span><br><span class="line">        loss_value.append(loss.data.item())</span><br><span class="line">        timer[<span class="string">&#x27;model&#x27;</span>] += self.split_time()</span><br><span class="line">        acc=self.get_acc(output,label)</span><br><span class="line">        acc_value.append(acc.data.item())</span><br><span class="line">        self.train_writer.add_scalar(<span class="string">&#x27;acc&#x27;</span>, acc, self.global_step)</span><br><span class="line">        self.train_writer.add_scalar(<span class="string">&#x27;loss&#x27;</span>, loss.data.item(), self.global_step)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># statistics</span></span><br><span class="line">        self.lr = self.optimizer.param_groups[<span class="number">0</span>][<span class="string">&#x27;lr&#x27;</span>]</span><br><span class="line">        self.train_writer.add_scalar(<span class="string">&#x27;lr&#x27;</span>, self.lr, self.global_step)</span><br><span class="line">        timer[<span class="string">&#x27;statistics&#x27;</span>] += self.split_time()</span><br><span class="line"></span><br><span class="line">    proportion = &#123;</span><br><span class="line">        k: <span class="string">&#x27;&#123;:02d&#125;%&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(v * <span class="number">100</span> / <span class="built_in">sum</span>(timer.values()))))</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> timer.items()</span><br><span class="line">    &#125;</span><br><span class="line">    self.print_log(</span><br><span class="line">        <span class="string">&#x27;\tMean training loss: &#123;:.4f&#125;.  Mean training acc: &#123;:.2f&#125;%.&#x27;</span>.<span class="built_in">format</span>(np.mean(loss_value), np.mean(acc_value)*<span class="number">100</span>))</span><br><span class="line">    self.print_log(<span class="string">&#x27;\tTime consumption: [Data]&#123;dataloader&#125;, [Network]&#123;model&#125;&#x27;</span>.<span class="built_in">format</span>(**proportion))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> save_model:</span><br><span class="line">        state_dict = self.model.state_dict()</span><br><span class="line">        weights = OrderedDict([[k.split(<span class="string">&#x27;module.&#x27;</span>)[-<span class="number">1</span>], v.cpu()] <span class="keyword">for</span> k, v <span class="keyword">in</span> state_dict.items()])</span><br><span class="line">        torch.save(weights, self.arg.model_saved_name + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(epoch+<span class="number">1</span>) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(self.global_step)) + <span class="string">&#x27;.pt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eval</span>(<span class="params">self, epoch, save_score=<span class="literal">False</span>, loader_name=[<span class="string">&#x27;test&#x27;</span>], wrong_file=<span class="literal">None</span>, result_file=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> wrong_file <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        f_w = <span class="built_in">open</span>(wrong_file, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> result_file <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        f_r = <span class="built_in">open</span>(result_file, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    self.model.<span class="built_in">eval</span>()</span><br><span class="line">    self.print_log(<span class="string">&#x27;Eval epoch: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> ln <span class="keyword">in</span> loader_name:</span><br><span class="line">        loss_value = []</span><br><span class="line">        score_frag = []</span><br><span class="line">        label_list = []</span><br><span class="line">        pred_list = []</span><br><span class="line">        acc_value=[]</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        process = tqdm(self.data_loader[ln], ncols=<span class="number">40</span>)</span><br><span class="line">        <span class="keyword">for</span> batch_idx, (data, label, index) <span class="keyword">in</span> <span class="built_in">enumerate</span>(process):</span><br><span class="line">            label_list.append(label)</span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                data = data.<span class="built_in">float</span>().cuda(self.output_device)</span><br><span class="line">                label = label.long().cuda(self.output_device)</span><br><span class="line">                output = self.model(data)</span><br><span class="line">                score_frag.append(output.data.cpu().numpy())</span><br><span class="line">                loss = self.loss(output, label)</span><br><span class="line">                acc = self.get_acc(output, label)</span><br><span class="line">                acc_value.append(acc.data.item())</span><br><span class="line">                loss_value.append(loss.data.item())</span><br><span class="line">                step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        loss = np.mean(loss_value)</span><br><span class="line">        accuracy=np.mean(acc_value)</span><br><span class="line">        <span class="keyword">if</span> accuracy &gt; self.best_acc:</span><br><span class="line">            self.best_acc = accuracy</span><br><span class="line">            self.best_acc_epoch = epoch + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Accuracy: &#x27;</span>, accuracy, <span class="string">&#x27; model: &#x27;</span>, self.arg.model_saved_name)</span><br><span class="line">        <span class="keyword">if</span> self.arg.phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            self.val_writer.add_scalar(<span class="string">&#x27;loss&#x27;</span>, loss, self.global_step)</span><br><span class="line">            self.val_writer.add_scalar(<span class="string">&#x27;acc&#x27;</span>, accuracy, self.global_step)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if save_score:</span></span><br><span class="line">        <span class="comment">#     score_pth=np.concatenate(score_frag,axis=0)</span></span><br><span class="line">        <span class="comment">#     print(score_pth.shape)</span></span><br><span class="line">        <span class="comment">#     torch.save(score_pth, &#x27;test.pth&#x27;)</span></span><br><span class="line">        self.print_log(<span class="string">&#x27;\tMean &#123;&#125; loss of &#123;&#125; batches: &#123;&#125;.&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            ln, <span class="built_in">len</span>(self.data_loader[ln]), np.mean(loss_value)))</span><br></pre></td></tr></table></figure>
<h3 id="邮件发送函数"><a href="#邮件发送函数" class="headerlink" title="邮件发送函数"></a>邮件发送函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">import</span> smtplib</span><br><span class="line">    <span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line">    <span class="comment"># 设置服务器所需信息</span></span><br><span class="line">    <span class="comment"># 邮箱服务器地址</span></span><br><span class="line">    mail_host = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 用户名</span></span><br><span class="line">    mail_user = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 密码(部分邮箱为授权码)</span></span><br><span class="line">    mail_pass = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 邮件发送方邮箱地址</span></span><br><span class="line">    sender = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 邮件接受方邮箱地址，注意需要[]包裹，这意味着你可以写多个邮件地址群发</span></span><br><span class="line">    receivers = [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置email信息</span></span><br><span class="line">    <span class="comment"># 邮件内容设置</span></span><br><span class="line">    message = MIMEText(text, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 邮件主题</span></span><br><span class="line">    message[<span class="string">&#x27;Subject&#x27;</span>] = <span class="string">&#x27;title&#x27;</span></span><br><span class="line">    <span class="comment"># 发送方信息</span></span><br><span class="line">    message[<span class="string">&#x27;From&#x27;</span>] = sender</span><br><span class="line">    <span class="comment"># 接受方信息</span></span><br><span class="line">    message[<span class="string">&#x27;To&#x27;</span>] = receivers[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 登录并发送邮件</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        smtpObj = smtplib.SMTP()</span><br><span class="line">        <span class="comment"># 连接到服务器</span></span><br><span class="line">        smtpObj.connect(mail_host, <span class="number">25</span>)</span><br><span class="line">        <span class="comment"># 登录到服务器</span></span><br><span class="line">        smtpObj.login(mail_user, mail_pass)</span><br><span class="line">        <span class="comment"># 发送</span></span><br><span class="line">        smtpObj.sendmail(</span><br><span class="line">            sender, receivers, message.as_string())</span><br><span class="line">        <span class="comment"># 退出</span></span><br><span class="line">        smtpObj.quit()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> smtplib.SMTPException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;error&#x27;</span>, e)  <span class="comment"># 打印错误</span></span><br></pre></td></tr></table></figure>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = get_parser()</span><br><span class="line">    <span class="comment"># load arg form config file</span></span><br><span class="line">    p = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> p.config <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(p.config, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            default_arg = yaml.safe_load(f)</span><br><span class="line">        key = <span class="built_in">vars</span>(p).keys()</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> default_arg.keys():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> key:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WRONG ARG: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(k))</span><br><span class="line">                <span class="keyword">assert</span> (k <span class="keyword">in</span> key)</span><br><span class="line">        parser.set_defaults(**default_arg)</span><br><span class="line"></span><br><span class="line">    arg = parser.parse_args()</span><br><span class="line">    init_seed(arg.seed)</span><br><span class="line">    processor = Processor(arg)</span><br><span class="line">    processor.start()</span><br></pre></td></tr></table></figure>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>用mnist数据集举例，一定要做的是<strong>len</strong>函数的重写和让<strong>getitem</strong>方法返回data,label,idx三个数据（对应main.py中的 <code>for batch_idx, (data, label, index) in enumerate(process):</code>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Feeder</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,debug=<span class="literal">False</span>, state=<span class="number">0</span></span>):</span><br><span class="line">        self.debug=debug</span><br><span class="line">        self.dataDownload()</span><br><span class="line">        self.state=state</span><br><span class="line">        self.load()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dataDownload</span>(<span class="params">self</span>):</span><br><span class="line">        trans = transforms.ToTensor()</span><br><span class="line">        self.mnist_train = torchvision.datasets.FashionMNIST(</span><br><span class="line">            root=<span class="string">&quot;../data&quot;</span>, train=<span class="literal">True</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">        self.mnist_test = torchvision.datasets.FashionMNIST(</span><br><span class="line">            root=<span class="string">&quot;../data&quot;</span>, train=<span class="literal">False</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="number">0</span>:</span><br><span class="line">            self.data = self.mnist_train</span><br><span class="line">        <span class="keyword">elif</span> self.state == <span class="number">1</span>:</span><br><span class="line">            self.data = self.mnist_test</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error state&quot;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        data_numpy,label=self.data[idx]</span><br><span class="line">        data_numpy=np.array(data_numpy)</span><br><span class="line">        <span class="keyword">return</span> data_numpy.astype(np.float32),label,idx</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">import_class</span>(<span class="params">name</span>):</span><br><span class="line">    components = name.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    mod = <span class="built_in">__import__</span>(components[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> comp <span class="keyword">in</span> components[<span class="number">1</span>:]:</span><br><span class="line">        mod = <span class="built_in">getattr</span>(mod, comp)</span><br><span class="line">    <span class="keyword">return</span> mod</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a=Feeder()</span><br></pre></td></tr></table></figure>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>下面提供一个配置文件示例<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">work_dir:</span> <span class="string">./work_dir/mnist</span></span><br><span class="line"><span class="comment">#weights: ./work_dir/skating/CW/runs-219-4380.pt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># feeder</span></span><br><span class="line"><span class="attr">feeder:</span> <span class="string">feeder.mnist.Feeder</span></span><br><span class="line"><span class="attr">train_feeder_args:</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">False</span></span><br><span class="line">  <span class="attr">state:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test_feeder_args:</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">False</span></span><br><span class="line">  <span class="attr">state:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># model</span></span><br><span class="line"><span class="attr">model:</span> <span class="string">model.net.LeNet</span></span><br><span class="line"><span class="attr">model_args:</span></span><br><span class="line">  <span class="attr">kernel_size:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">padding:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">stride:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#training</span></span><br><span class="line"><span class="attr">device:</span> [<span class="number">0</span>]</span><br><span class="line"><span class="attr">batch_size:</span> <span class="number">16</span></span><br><span class="line"><span class="attr">test_batch_size:</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#optim</span></span><br><span class="line"><span class="attr">base_lr:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">step:</span> [<span class="number">150</span>, <span class="number">225</span>]</span><br><span class="line"><span class="attr">num_epoch:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">lr_decay_rate:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">warm_up_epoch:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">save_epoch:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">seed:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<h2 id="开始食用"><a href="#开始食用" class="headerlink" title="开始食用"></a>开始食用</h2><p>运行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py --config config/config.yaml --device 0</span><br></pre></td></tr></table></figure><br>启动tensorboard<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir=work_dir/mnist/runs --bind_all</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于快速排序的一些优化方法</title>
    <url>/2022/09/15/quicksort/</url>
    <content><![CDATA[<h2 id="排序前的有序性检查"><a href="#排序前的有序性检查" class="headerlink" title="排序前的有序性检查"></a>排序前的有序性检查</h2><p>我们可以在快速排序算法的每个递归子数组排序前进行有序性检查，无序时才进行排序操作。</p>
<h2 id="避免重复交换和枢轴重复的数字"><a href="#避免重复交换和枢轴重复的数字" class="headerlink" title="避免重复交换和枢轴重复的数字"></a>避免重复交换和枢轴重复的数字</h2><p>我们可以对每趟使用一种三路的划分策略，既将数组分为比目标大，比目标小和等于目标三个部分。使用left和right表示最左侧和最右侧的下标，下标l和r表示左侧和右侧的游标，i表示中间的游标，递归算法设计如下：</p>
<ul>
<li>初始化：left=0，right=数组长度-1，l=left,r=right,i=l+1，数组array</li>
<li>递归终止判定：left&gt;=right</li>
<li>递归过程：当i&lt;=r时，循环比对pivot枢轴和array[i]，若array[i]小于pivot,i和l位置互换，i++,l++；若array[i]大于pivot,i和r位置互换,r—;若array[i]=pivot，i++。</li>
<li>然后分治递归（left,l-1)和(r+1,right)。</li>
</ul>
<h2 id="三数取中法"><a href="#三数取中法" class="headerlink" title="三数取中法"></a>三数取中法</h2><p>取三个元素（一般是第一个、最后一个和中间的元素）的中间值作为基准。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp=array[left];</span><br><span class="line">    array[left]=array[right];</span><br><span class="line">    array[right]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkSorted</span><span class="params">(vector&lt;<span class="type">int</span>&gt; array,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cmp=array[left];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]&gt;=cmp) cmp=array[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPivot</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x1=array[left];</span><br><span class="line">    <span class="type">int</span> x2=array[right];</span><br><span class="line">    <span class="type">int</span> x3=array[(left+right)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(x1&gt;=x2 &amp;&amp; x1&gt;=x3)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x2&gt;=x1 &amp;&amp; x2&gt;=x3)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(array,left,right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(array,left,(left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">checkSorted</span>(array, left, right)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> l=left;</span><br><span class="line">    <span class="type">int</span> r=right;</span><br><span class="line">    <span class="built_in">getPivot</span>(array,l,r);</span><br><span class="line">    <span class="type">int</span> i=left+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cmp=array[l];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]&lt;cmp)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(array,i,l);</span><br><span class="line">            i++;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array[i]&gt;cmp)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(array,i,r);</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quicksort</span>(array,left,l<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quicksort</span>(array,r+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;array[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; array=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;初始数组顺序&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printArray</span>(array);</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right=array.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">quicksort</span>(array,left,right);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;排序后数组顺序&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printArray</span>(array);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>基于selenium的大连理工大学研究生抢课脚本</title>
    <url>/2022/09/02/pyaudio/</url>
    <content><![CDATA[<p>2022年9月1日，这是笔者被学校的土豆服务器气到自闭的一天。早上8:00开始选课，9:20笔者才进了选课系统，期间手点鼠标点到快抽筋。。。不出意外地，所有需要抢的课都被抢走了。然后，笔者所在的研究生大群里竟然有人商量着换课，这种行为对笔者造成了极大的精神伤害，下面的抢课脚本就是在这个情况下诞生的。（是的，我们不是想挤压已经压力山大的服务器，而是想制裁那些试图交易换课的人。）</p>
<p>（项目稍晚将会发布到笔者的github，先鸽。）</p>
<h2 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h2><p>selenium是python中的一个自动化测试库，使用文档可以参考：<a href="https://selenium-python-zh.readthedocs.io">https://selenium-python-zh.readthedocs.io</a></p>
<h2 id="driver初始化"><a href="#driver初始化" class="headerlink" title="driver初始化"></a>driver初始化</h2><p>首先要对浏览器进行配置，重要的是<code>option.add_argument(&#39;headless&#39;) # 设置option</code>这一行，这样浏览器会在后台运行，但在我们测试时，我们可以不设置这个参数，让浏览器在前台可视化运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">option=webdriver.ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">&#x27;headless&#x27;</span>) <span class="comment"># 设置option</span></span><br><span class="line">option.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>)</span><br><span class="line">option.add_argument(<span class="string">&#x27;--disable-dev-shm-usage&#x27;</span>)</span><br><span class="line"><span class="comment"># driver = webdriver.Chrome() # 显示界面执行，测试时用</span></span><br><span class="line">driver = webdriver.Chrome(chrome_options=option)  <span class="comment"># 调用带参数的谷歌浏览器</span></span><br><span class="line">driver.implicitly_wait(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h2 id="研究生管理系统登陆"><a href="#研究生管理系统登陆" class="headerlink" title="研究生管理系统登陆"></a>研究生管理系统登陆</h2><p>经过测试我们发现，在<a href="https://sso.dlut.edu.cn/cas/login?service=http://202.118.65.123/gmis/LoginCAS.aspx">https://sso.dlut.edu.cn/cas/login?service=http://202.118.65.123/gmis/LoginCAS.aspx</a>上登陆之后，才可以访问202.118.65.123上的内容，也就是我们的研究生管理系统。因此，我们首先要登陆管理系统。我们在这里通过id查找到输入用户名和密码的位置，输入后回车。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stuid=<span class="string">&quot;&quot;</span> <span class="comment">#用户名</span></span><br><span class="line">secret=<span class="string">&quot;&quot;</span> <span class="comment">#密码</span></span><br><span class="line">driver.get(<span class="string">&quot;https://sso.dlut.edu.cn/cas/login?service=http://202.118.65.123/gmis/LoginCAS.aspx&quot;</span>) <span class="comment"># 输入网址</span></span><br><span class="line">elem = driver.find_elements(by=<span class="string">&quot;id&quot;</span>,value=<span class="string">&quot;un&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">elem.clear()</span><br><span class="line">elem.send_keys(stuid)</span><br><span class="line">elem = driver.find_elements(by=<span class="string">&quot;id&quot;</span>,value=<span class="string">&quot;pd&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">elem.clear()</span><br><span class="line">elem.send_keys(secret)</span><br><span class="line">elem.send_keys(Keys.RETURN)</span><br></pre></td></tr></table></figure>
<h2 id="选课核心逻辑"><a href="#选课核心逻辑" class="headerlink" title="选课核心逻辑"></a>选课核心逻辑</h2><p>选课的核心逻辑必然是进入选课页面-&gt;选课-&gt;选不到课继续选-&gt;选到课结束。</p>
<p>进入核心页面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.get(<span class="string">&quot;http://202.118.65.123/pyxx/pygl/pyjhxk.aspx?xh=&quot;</span> + stuid)</span><br></pre></td></tr></table></figure>
<p>选课：</p>
<p>根据要选择按键的value定位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">elem = driver.find_element(by=<span class="string">&quot;id&quot;</span>, value=<span class="string">&quot;MainWork_dgData_Linkbutton2_122&quot;</span>)</span><br><span class="line">      <span class="comment">#       # 测试：林鸿飞 信息检索</span></span><br><span class="line">      <span class="comment"># elem = driver.find_element(by=&quot;id&quot;, value=&quot;MainWork_dgData_Linkbutton2_131&quot;)</span></span><br><span class="line">      <span class="built_in">print</span>(elem.text)</span><br><span class="line">      <span class="keyword">assert</span> elem.text == <span class="string">&#x27;选课&#x27;</span></span><br><span class="line">      elem.click()</span><br></pre></td></tr></table></figure>
<p>基于alert messagebox的逻辑处理，使用断言来保证逻辑的正确执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alert = driver.switch_to.alert</span><br><span class="line">                <span class="keyword">assert</span> alert.text == <span class="string">&#x27;确定要选择该课程？&#x27;</span></span><br><span class="line">                <span class="built_in">print</span>(alert.text)</span><br><span class="line">                alert.accept()  <span class="comment"># 去除浏览器警告</span></span><br></pre></td></tr></table></figure>
<h2 id="战绩"><a href="#战绩" class="headerlink" title="战绩"></a>战绩</h2><p>截止9月3日7:00，本脚本已经为笔者截到《云计算》、《优化方法》两门课程。</p>
<h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><p>不支持多线程；对不了解html的用户不友好，需要结合爬虫实现辅助获取按键value的功能等。</p>
]]></content>
      <categories>
        <category>随便写的玩意</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python绘制骨架图</title>
    <url>/2022/07/26/plotskeleton/</url>
    <content><![CDATA[<p>openpose25:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># import torchvision</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"></span><br><span class="line">x=np.load(<span class="string">&quot;961.npz.npy&quot;</span>)</span><br><span class="line">C, T, V, M = x.shape</span><br><span class="line">x=x[:,<span class="number">0</span>:<span class="number">129</span>,:,:]</span><br><span class="line"><span class="comment"># cnt=0</span></span><br><span class="line"><span class="comment"># for i in range(T - 1, -1, -1):</span></span><br><span class="line"><span class="comment">#     tmp = np.sum(x[:, i, :, :])</span></span><br><span class="line"><span class="comment">#     if tmp &gt; 0:</span></span><br><span class="line"><span class="comment">#         cnt = cnt + 1</span></span><br><span class="line"><span class="comment"># print(cnt)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x.shape)</span><br><span class="line">point=x</span><br><span class="line">xmax= np.<span class="built_in">max</span>(point[<span class="number">0</span>, :, :, :])+ <span class="number">0.5</span></span><br><span class="line">xmin= np.<span class="built_in">min</span>(point[<span class="number">0</span>, :, :, :])- <span class="number">0.5</span></span><br><span class="line">ymax= np.<span class="built_in">max</span>(point[<span class="number">1</span>, :, :, :])+ <span class="number">0.3</span></span><br><span class="line">ymin= np.<span class="built_in">min</span>(point[<span class="number">1</span>, :, :, :])- <span class="number">0.3</span></span><br><span class="line">arms= np.array([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]) <span class="comment">#胳膊</span></span><br><span class="line">rightHand= np.array([<span class="number">24</span>,<span class="number">11</span>]) <span class="comment">#右手</span></span><br><span class="line">leftHand= np.array([<span class="number">21</span>,<span class="number">14</span>]) <span class="comment">#左手</span></span><br><span class="line">legs= np.array([<span class="number">23</span>,<span class="number">22</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">19</span>,<span class="number">20</span>])  <span class="comment">#腿</span></span><br><span class="line">body= np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>])   <span class="comment">#身体</span></span><br><span class="line">head=np.array([<span class="number">17</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">16</span>,<span class="number">18</span>])</span><br><span class="line">row= point.shape[<span class="number">1</span>] <span class="comment">#有多少帧</span></span><br><span class="line">n = <span class="number">0</span>  <span class="comment"># 从第n帧开始展示</span></span><br><span class="line">m = <span class="number">30</span>  <span class="comment"># 到第m帧结束，n&lt;m&lt;row，这个m可以选取一个小于最大帧数的阈值，便于查看，若m=1则展示一帧</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.ion()  <span class="comment"># 使用plt.ion()这个函数，使matplotlib的显示模式转换为交互（interactive）模式。即使在脚本中遇到plt.show()，代码还是会继续执行。</span></span><br><span class="line">color_point = <span class="string">&#x27;#03ff&#x27;</span>  <span class="comment"># 关节点颜色,可输入16进制调色板</span></span><br><span class="line">color_bone = <span class="string">&#x27;red&#x27;</span>  <span class="comment"># 骨骼颜色</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, m):</span><br><span class="line">    plt.cla()  <span class="comment">## Clear axis即清除当前图形中的当前活动轴。其他轴不受影响。</span></span><br><span class="line">    plt.scatter(point[<span class="number">0</span>, i, :, :], -point[<span class="number">1</span>, i, :, :], c=color_point, s=<span class="number">40.0</span>)  <span class="comment"># 通过散点图绘制关节点</span></span><br><span class="line">    <span class="comment"># 通过直线图绘制两点间的连接线，即骨骼</span></span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, arms, <span class="number">0</span>], -point[<span class="number">1</span>, i, arms, <span class="number">0</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, rightHand, <span class="number">0</span>], -point[<span class="number">1</span>, i, rightHand, <span class="number">0</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, leftHand, <span class="number">0</span>], -point[<span class="number">1</span>, i, leftHand, <span class="number">0</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, legs, <span class="number">0</span>], -point[<span class="number">1</span>, i, legs, <span class="number">0</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, body, <span class="number">0</span>], -point[<span class="number">1</span>, i, body, <span class="number">0</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, head, <span class="number">0</span>], -point[<span class="number">1</span>, i, head, <span class="number">0</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">    plt.text(xmax - <span class="number">0.5</span>, ymax - <span class="number">0.1</span>, <span class="string">&#x27;frame: &#123;&#125;/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i, row - <span class="number">1</span>))  <span class="comment"># 这是第几帧</span></span><br><span class="line">    plt.xlim(xmin, xmax)  <span class="comment"># 坐标轴</span></span><br><span class="line">    plt.ylim(ymin, ymax)</span><br><span class="line">    plt.pause(<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>ntu-pose</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">r&#x27;C:\Users\lenovo\Desktop\visiual/S001C001P001R001A009.skeleton&#x27;</span></span><br><span class="line">max_V = <span class="number">25</span> <span class="comment">#节点数</span></span><br><span class="line">max_M = <span class="number">2</span> <span class="comment">#骨架数量</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fr:</span><br><span class="line">    frame_num = <span class="built_in">int</span>(fr.readline())</span><br><span class="line">    point = np.zeros((<span class="number">3</span>, frame_num, <span class="number">25</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">for</span> frame <span class="keyword">in</span> <span class="built_in">range</span>(frame_num):</span><br><span class="line">        person_num = <span class="built_in">int</span>(fr.readline())</span><br><span class="line">        <span class="keyword">for</span> person <span class="keyword">in</span> <span class="built_in">range</span>(person_num):</span><br><span class="line">            fr.readline()</span><br><span class="line">            joint_num = <span class="built_in">int</span>(fr.readline())</span><br><span class="line">            <span class="keyword">for</span> joint <span class="keyword">in</span> <span class="built_in">range</span>(joint_num):</span><br><span class="line">                v = fr.readline().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> joint &lt; max_V <span class="keyword">and</span> person &lt; max_M:</span><br><span class="line">                    point[<span class="number">0</span>,frame,joint,person] = <span class="built_in">float</span>(v[<span class="number">0</span>])<span class="comment">#一个关节的一个坐标</span></span><br><span class="line">                    point[<span class="number">1</span>,frame,joint,person] = <span class="built_in">float</span>(v[<span class="number">1</span>])</span><br><span class="line">                    point[<span class="number">2</span>,frame,joint,person] = <span class="built_in">float</span>(v[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read data done!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(point.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过最大最小的坐标值来选取合适的坐标轴 </span></span><br><span class="line">xmax= np.<span class="built_in">max</span>(point[<span class="number">0</span>, :, :, :])+ <span class="number">0.5</span></span><br><span class="line">xmin= np.<span class="built_in">min</span>(point[<span class="number">0</span>, :, :, :])- <span class="number">0.5</span></span><br><span class="line">ymax= np.<span class="built_in">max</span>(point[<span class="number">1</span>, :, :, :])+ <span class="number">0.3</span></span><br><span class="line">ymin= np.<span class="built_in">min</span>(point[<span class="number">1</span>, :, :, :])- <span class="number">0.3</span></span><br><span class="line">zmax= np.<span class="built_in">max</span>(point[<span class="number">2</span>, :, :, :])</span><br><span class="line">zmin= np.<span class="built_in">min</span>(point[<span class="number">2</span>, :, :, :])</span><br><span class="line"> </span><br><span class="line">row= point.shape[<span class="number">1</span>] <span class="comment">#有多少帧</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 根据NTU骨架结构确定哪几个节点相连为骨骼</span></span><br><span class="line"><span class="comment"># 注意序号从0开始，需要减1</span></span><br><span class="line">arms= np.array([<span class="number">24</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">21</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">20</span>])-<span class="number">1</span> <span class="comment">#胳膊</span></span><br><span class="line">rightHand= np.array([<span class="number">12</span>,<span class="number">25</span>])-<span class="number">1</span> <span class="comment">#右手</span></span><br><span class="line">leftHand= np.array([<span class="number">8</span>,<span class="number">23</span>])-<span class="number">1</span> <span class="comment">#左手</span></span><br><span class="line">legs= np.array([<span class="number">20</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]) - <span class="number">1</span> <span class="comment">#腿</span></span><br><span class="line">body= np.array([<span class="number">4</span>,<span class="number">3</span>,<span class="number">21</span>,<span class="number">2</span>,<span class="number">1</span>]) -<span class="number">1</span>  <span class="comment">#身体</span></span><br><span class="line"> </span><br><span class="line">n= <span class="number">0</span>     <span class="comment"># 从第n帧开始展示</span></span><br><span class="line">m= <span class="number">2</span> <span class="comment"># 到第m帧结束，n&lt;m&lt;row，这个m可以选取一个小于最大帧数的阈值，便于查看，若m=1则展示一帧</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.ion() <span class="comment">#使用plt.ion()这个函数，使matplotlib的显示模式转换为交互（interactive）模式。即使在脚本中遇到plt.show()，代码还是会继续执行。</span></span><br><span class="line">color_point = <span class="string">&#x27;#03ff&#x27;</span> <span class="comment">#关节点颜色,可输入16进制调色板</span></span><br><span class="line">color_bone = <span class="string">&#x27;red&#x27;</span> <span class="comment">#骨骼颜色</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, m):</span><br><span class="line">    plt.cla() <span class="comment">## Clear axis即清除当前图形中的当前活动轴。其他轴不受影响。</span></span><br><span class="line">    plt.scatter(point[<span class="number">0</span>, i, :, :], point[<span class="number">1</span>, i, :, :], c=color_point, s=<span class="number">40.0</span>) <span class="comment">#通过散点图绘制关节点</span></span><br><span class="line">    <span class="comment">#通过直线图绘制两点间的连接线，即骨骼</span></span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, arms,<span class="number">0</span>], point[<span class="number">1</span>, i, arms,<span class="number">0</span>], c=color_bone, lw=<span class="number">2.0</span>) </span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, rightHand,<span class="number">0</span>], point[<span class="number">1</span>, i, rightHand,<span class="number">0</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, leftHand,<span class="number">0</span>], point[<span class="number">1</span>, i, leftHand,<span class="number">0</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, legs,<span class="number">0</span>], point[<span class="number">1</span>, i, legs,<span class="number">0</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, body,<span class="number">0</span>], point[<span class="number">1</span>, i, body,<span class="number">0</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#第二个骨架，如果有的话</span></span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, arms,<span class="number">1</span>], point[<span class="number">1</span>, i, arms,<span class="number">1</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, rightHand,<span class="number">1</span>], point[<span class="number">1</span>, i, rightHand,<span class="number">1</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, leftHand,<span class="number">1</span>], point[<span class="number">1</span>, i, leftHand,<span class="number">1</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, legs,<span class="number">1</span>], point[<span class="number">1</span>, i, legs,<span class="number">1</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">    plt.plot(point[<span class="number">0</span>, i, body,<span class="number">1</span>], point[<span class="number">1</span>, i, body,<span class="number">1</span>], c=color_bone, lw=<span class="number">2.0</span>)</span><br><span class="line">     </span><br><span class="line">    plt.text(xmax-<span class="number">0.5</span>, ymax-<span class="number">0.1</span>,<span class="string">&#x27;frame: &#123;&#125;/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i, row-<span class="number">1</span>)) <span class="comment">#这是第几帧</span></span><br><span class="line">    <span class="comment"># plt.text(xmax-0.8, ymax-0.4, &#x27;label: &#x27; + str(label[i]))</span></span><br><span class="line">    plt.xlim(xmin, xmax) <span class="comment">#坐标轴</span></span><br><span class="line">    plt.ylim(ymin, ymax)</span><br><span class="line">    plt.pause(<span class="number">0.001</span>)</span><br><span class="line"> </span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>scp指令--文件传输</title>
    <url>/2022/05/26/scp/</url>
    <content><![CDATA[<p>在linux下一般用scp这个命令来通过ssh传输文件。</p>
<p>1、从服务器上下载文件</p>
<p>scp username@servername:&#x2F;path&#x2F;filename &#x2F;var&#x2F;www&#x2F;local_dir（本地目录）</p>
<p>例如scp <a href="mailto:&#114;&#111;&#x6f;&#x74;&#64;&#x31;&#57;&#x32;&#46;&#49;&#x36;&#56;&#x2e;&#x30;&#x2e;&#x31;&#x30;&#x31;">&#114;&#111;&#x6f;&#x74;&#64;&#x31;&#57;&#x32;&#46;&#49;&#x36;&#56;&#x2e;&#x30;&#x2e;&#x31;&#x30;&#x31;</a>:&#x2F;var&#x2F;www&#x2F;test.txt 把192.168.0.101上的&#x2F;var&#x2F;www&#x2F;test.txt 的文件下载到&#x2F;var&#x2F;www&#x2F;local_dir（本地目录）</p>
<p>2、上传本地文件到服务器</p>
<p>scp &#x2F;path&#x2F;filename username@servername:&#x2F;path</p>
<p>例如scp &#x2F;var&#x2F;www&#x2F;test.php <a href="mailto:&#114;&#111;&#x6f;&#x74;&#64;&#49;&#57;&#50;&#x2e;&#49;&#54;&#56;&#x2e;&#x30;&#46;&#49;&#x30;&#x31;">&#114;&#111;&#x6f;&#x74;&#64;&#49;&#57;&#50;&#x2e;&#49;&#54;&#56;&#x2e;&#x30;&#46;&#49;&#x30;&#x31;</a>:&#x2F;var&#x2F;www&#x2F; 把本机&#x2F;var&#x2F;www&#x2F;目录下的test.php文件上传到192.168.0.101这台服务器上的&#x2F;var&#x2F;www&#x2F;目录</p>
<p>3、从服务器下载整个目录</p>
<p>scp -r username@servername:&#x2F;var&#x2F;www&#x2F;remote_dir&#x2F;（远程目录） &#x2F;var&#x2F;www&#x2F;local_dir（本地目录）</p>
<p>例如:scp -r <a href="mailto:&#x72;&#111;&#x6f;&#116;&#64;&#x31;&#57;&#50;&#x2e;&#x31;&#54;&#56;&#46;&#x30;&#x2e;&#x31;&#x30;&#49;">&#x72;&#111;&#x6f;&#116;&#64;&#x31;&#57;&#50;&#x2e;&#x31;&#54;&#56;&#46;&#x30;&#x2e;&#x31;&#x30;&#49;</a>:&#x2F;var&#x2F;www&#x2F;test &#x2F;var&#x2F;www&#x2F;</p>
<p>4、上传目录到服务器</p>
<p>scp -r local_dir username@servername:remote_dir</p>
<p>例如：scp -r test <a href="mailto:&#114;&#x6f;&#111;&#116;&#x40;&#49;&#x39;&#x32;&#46;&#49;&#x36;&#56;&#46;&#x30;&#46;&#x31;&#48;&#x31;">&#114;&#x6f;&#111;&#116;&#x40;&#49;&#x39;&#x32;&#46;&#49;&#x36;&#56;&#46;&#x30;&#46;&#x31;&#48;&#x31;</a>:&#x2F;var&#x2F;www&#x2F; 把当前目录下的test目录上传到服务器的&#x2F;var&#x2F;www&#x2F; 目录</p>
]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title>人脸识别损失函数发展</title>
    <url>/2022/05/25/faceloss/</url>
    <content><![CDATA[<h2 id="分类任务基本流程"><a href="#分类任务基本流程" class="headerlink" title="分类任务基本流程"></a>分类任务基本流程</h2><p>一个传统的基于神经网络的n分类任务可以用以下步骤表示。</p>
<p>1.使用多层神经网络，对输入数据X提取出m维的特征向量$\overrightarrow{x}$。</p>
<script type="math/tex; mode=display">\overrightarrow{x}=F(X)</script><p>2.通过全连接层FC，将$\overrightarrow{x}$线性映射到n维的向量$\overrightarrow{z}$，其中$z_j$越大，表示属于第j类的概率越大。</p>
<script type="math/tex; mode=display">\overrightarrow{z}=f(\overrightarrow{x})</script><p>3.使用softmax分类器将$\overrightarrow{z}$归一化为概率向量$\overrightarrow{a}$，其中$a_j$表示属于第j类的概率。</p>
<script type="math/tex; mode=display">\overrightarrow{a}=softmax(\overrightarrow{z})</script><p>4.通过交叉熵损失函数求loss。</p>
<h2 id="softmax-loss"><a href="#softmax-loss" class="headerlink" title="softmax loss"></a>softmax loss</h2><p>人脸识别任务中最常用的损失函数是softmax loss，是将上文提到的softmax分类器和交叉熵损失相结合的方法。</p>
<script type="math/tex; mode=display">L_s=\frac{1}{N}\sum_{i=1}^{N}{-ln\frac{e^{z_{y_i}}}{\sum_{j=1}^{C}e^{z_j}}}</script><p>softmax loss的分类效果如下图所示。</p>
<img src="/2022/05/25/faceloss/1.png" class="" title="softmaxloss分类效果">
<p>softmax loss在人脸识别的问题：对于类内的约束不好，因此当分类比较多时或者样本差距比较小时，softmax监督效果不够。</p>
<h2 id="L2-softmax"><a href="#L2-softmax" class="headerlink" title="L2-softmax"></a>L2-softmax</h2><p>上文的全连接层可以用以下形式表示。</p>
<script type="math/tex; mode=display">z=Wx</script><p>对特征进行归一化。</p>
<script type="math/tex; mode=display">y=\alpha \cdot \frac{x}{\|x\|_2}</script><p>因此,得到L2-softmax。</p>
<script type="math/tex; mode=display">z=Wy</script><p>特征归一化的优势：将特征向量映射到半径为1的范围，便于理解和优化。</p>
<h2 id="Margin-Based-Loss-Function"><a href="#Margin-Based-Loss-Function" class="headerlink" title="Margin Based Loss Function"></a>Margin Based Loss Function</h2><p>基于边际的损失函数的标准形式，缩小权值向量W和特征向量f之间的夹角。</p>
<script type="math/tex; mode=display">\mathcal{L}=-log\frac{exp(f(\theta_{y_i},m))}{exp(f(\theta_{y_i},m))+\sum_{j\neq y_i}^{}exp(scos\theta_j)}</script><p>sphereFace: 使用乘法角度间隔。</p>
<script type="math/tex; mode=display">f(\theta_j,m)_{sphereFace}=\left\{
\begin{aligned}
scos(\theta_j ) && j=y_i\\
scos\theta_j && j\neq y_i\\
\end{aligned}
\right.</script><p>LMCL和arcFace:使用加法角度间隔，相比乘法间隔加快了收敛速度。</p>
<p>LMCL：</p>
<script type="math/tex; mode=display">f(\theta_j,m)_{LMCL}=\left\{
\begin{aligned}
s(cos\theta_j -m) && j=y_i\\
scos\theta_j && j\neq y_i\\
\end{aligned}
\right.</script><p>arcFace：</p>
<script type="math/tex; mode=display">f(\theta_j,m)_{arcFace}=\left\{
\begin{aligned}
scos(\theta_j +m) && j=y_i\\
scos\theta_j && j\neq y_i\\
\end{aligned}
\right.</script><img src="/2022/05/25/faceloss/2.png" class="" title="softmaxloss分类效果">
<p>MagFace：额外考虑了对类内分布的精细化处理。</p>
<script type="math/tex; mode=display">\mathcal{L}=-log\frac{exp(scos(\theta_j +m(a_i)))}{exp(scos(\theta_j +m(a_i))))+\sum_{j\neq y_i}^{}exp(scos\theta_j)}+\lambda_gg(a_i)</script><p>MagFace主要做了两处改进，第一是把ArcFace的loss函数中角度间隔惩罚由常数项$m$ 改成了基于特征模长 $a_i$ 的函数 $m(a_i)$ ，同时增加一个基于模长的惩罚项 $g(a_i)$。</p>
<p>AdaFace: 简单或困难样本的相对重要性应该基于样本的图像质量来给定。</p>
<script type="math/tex; mode=display">f(\theta_j,m)_{AdaFace}=\left\{
\begin{aligned}
scos(\theta_j +g_{angle})-g_{add} && j=y_i\\
scos\theta_j && j\neq y_i\\
\end{aligned}
\right.</script><h2 id="多采样的loss"><a href="#多采样的loss" class="headerlink" title="多采样的loss"></a>多采样的loss</h2><p>Contrastive Loss：有效的处理这种网络中的成对数据的关系。</p>
<p>对比损失一次采样两个样本,通常是使用图中这种孪生网络来处理成对数据的关系。</p>
<p>Triplet Loss：三元组损失</p>
<p>Triplet Loss是通过基准样本，正样本，负样本三者进行度量，目标是让正样本离Anchor更近，负样本离Anchor更远。普遍来说，这些多采样的方法很善于对相似样本区分，但弱点是占用的空间和时间往往会比较高。</p>
<h2 id="增加额外约束的loss"><a href="#增加额外约束的loss" class="headerlink" title="增加额外约束的loss"></a>增加额外约束的loss</h2><p>center loss：<br>另一种改进的方向是采用联合监督的损失函数，就是用一个额外的损失函数辅助约束样本。代表的就是center loss，这是一种以特征向量到中心向量的距离作为度量的损失函数。图中使用lambda的center loss+softmax代表损失函数，lambda决定了center loss所占权重。可以看出，center loss对于类内的约束很好，弱点就是以及使用的这个中心矩阵C所占空间太大。我们也是基于这种联合监督的思想提出了一个时空鲁棒的损失函数用于时序的识别问题。</p>
]]></content>
      <categories>
        <category>深度学习杂谈</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>docker使用教程</title>
    <url>/2022/05/18/docker/</url>
    <content><![CDATA[<blockquote>
<p>详细资料导航：<a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></p>
</blockquote>
<h2 id="在mac上安装docker"><a href="#在mac上安装docker" class="headerlink" title="在mac上安装docker"></a>在mac上安装docker</h2><p>将docker应用安装到mac的应用程序列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install --cask --appdir=/Applications docker</span><br></pre></td></tr></table></figure>

<h2 id="常用docker命令"><a href="#常用docker命令" class="headerlink" title="常用docker命令"></a>常用docker命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\\获取镜像 exp：载入 ubuntu 镜像</span><br><span class="line">docker pull ubuntu</span><br><span class="line"></span><br><span class="line">\\启动一个容器 exp:启动ubuntu镜像,-i: 交互式操作,-t: 终端,-d: 后台运行，不会进入容器,ubuntu: ubuntu 镜像,/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash，<span class="built_in">exec</span>指令进入后台运行的容器。</span><br><span class="line">docker run -it ubuntu /bin/bash</span><br><span class="line">docker <span class="built_in">exec</span> -it [<span class="built_in">id</span>] /bin/bash</span><br><span class="line"></span><br><span class="line">\\查看所有容器</span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line">\\使用 docker start 启动一个已停止的容器：</span><br><span class="line">docker start [<span class="built_in">id</span>]</span><br><span class="line"></span><br><span class="line">\\停止一个容器</span><br><span class="line">docker stop [<span class="built_in">id</span>]</span><br><span class="line"></span><br><span class="line">\\重启一个容器</span><br><span class="line">docker restart [<span class="built_in">id</span>]</span><br><span class="line"></span><br><span class="line">\\导出容器到镜像</span><br><span class="line">docker <span class="built_in">export</span> [<span class="built_in">id</span>] &gt; [name].tar</span><br><span class="line"></span><br><span class="line">\\导入容器快照 </span><br><span class="line"><span class="built_in">cat</span> docker/ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1</span><br><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br><span class="line"></span><br><span class="line">\\删除容器</span><br><span class="line">docker <span class="built_in">rm</span> -f 1e560fca3906</span><br><span class="line"></span><br><span class="line">\\端口映射,使用UDP时可以在端口后面加上 /udp。</span><br><span class="line">docker run -d -p 127.0.0.1:5001:5000 [image] [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure>

<p>\提交为新镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -m=<span class="string">&quot;修改了首页&quot;</span> -a=<span class="string">&quot;华安&quot;</span> mytomcat huaan/tomcat:v1.0</span><br></pre></td></tr></table></figure>

<h2 id="使用docker建立一个指纹识别系统服务"><a href="#使用docker建立一个指纹识别系统服务" class="headerlink" title="使用docker建立一个指纹识别系统服务"></a>使用docker建立一个指纹识别系统服务</h2><p>笔者此前曾编写过一个指纹对比程序，现在我们将程序植入docker，让没有环境的用户也能便于使用。</p>
<p>首先我们pull一个ubuntu docker<code>docker pull ubuntu</code>。</p>
<p>然后我们把指纹识别程序的代码下载下来<code>git clone https://github.com/dingyn-Reno/finger_cmp.git</code>。</p>
<p>按照finger_cmp文档的提示安装必要环境，然后尝试运行代码，这里存在一个问题，参考<a href="https://www.codeleading.com/article/39394780173/">https://www.codeleading.com/article/39394780173/</a>可解决。</p>
<p>接下来导出容器<code>docker export 3d8281e28ee6 &gt; finger.tar</code>，记录下之前使用的版本号，重新导入镜像进行测试。</p>
<p>也可以使用commit指令提交完整镜像<code>docker commit -m=&quot;fingerprint&quot; -a=&quot;dingyn&quot; 3d8281e28ee6 python:v1.0</code>。</p>
]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn2021公开赛 write-up</title>
    <url>/2021/06/01/ciscn2021/</url>
    <content><![CDATA[<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h3 id="glass-solver-wxc"><a href="#glass-solver-wxc" class="headerlink" title="glass (solver: wxc)"></a>glass (solver: wxc)</h3><p>找本地库函数，反解算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> *</span><br><span class="line">key = <span class="string">&quot;12345678&quot;</span></span><br><span class="line">flag = [<span class="number">163</span>, <span class="number">26</span>, <span class="number">227</span>, <span class="number">105</span>, <span class="number">47</span>, <span class="number">187</span>, <span class="number">26</span>, <span class="number">132</span>, <span class="number">101</span>, <span class="number">194</span>, <span class="number">173</span>, <span class="number">173</span>, <span class="number">158</span>, <span class="number">150</span>, <span class="number">5</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">31</span>, <span class="number">142</span>, <span class="number">54</span>, <span class="number">79</span>, <span class="number">225</span>, <span class="number">235</span>, <span class="number">175</span>, <span class="number">240</span>, <span class="number">234</span>, <span class="number">196</span>, <span class="number">168</span>, <span class="number">45</span>, <span class="number">66</span>, <span class="number">199</span>, <span class="number">110</span>, <span class="number">63</span>, <span class="number">176</span>,</span><br><span class="line"><span class="number">211</span>, <span class="number">204</span>, <span class="number">120</span>, <span class="number">249</span>, <span class="number">152</span>, <span class="number">63</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">39</span>, <span class="number">8</span>):</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">if</span> (j + i &lt; <span class="number">39</span>):</span><br><span class="line">      flag[j + i] ^= <span class="built_in">ord</span>(key[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">39</span>, <span class="number">3</span>):</span><br><span class="line">  flag[i + <span class="number">1</span>] ^= flag[i]</span><br><span class="line">  flag[i + <span class="number">2</span>] ^= flag[i + <span class="number">1</span>]</span><br><span class="line">  flag[i] ^= flag[i + <span class="number">2</span>]</span><br><span class="line">cipher1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">39</span>):</span><br><span class="line">        cipher += flag[i]</span><br><span class="line">flag = ARC4.new(key).decrypt(cipher1)</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure>

<h3 id="babe-bc-solver-wxc"><a href="#babe-bc-solver-wxc" class="headerlink" title="babe bc (solver: wxc)"></a>babe bc (solver: wxc)</h3><p>先用llvm-dis获得llvm ir文件，得到矩阵行列，再用放出来的提示文件，发现是个填数字的游戏，找到规则，填数字即可。</p>
<img src="/2021/06/01/ciscn2021/1.png" class="" title="图片引用方法一">

<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="easy-source-solver-Yuning-Ding"><a href="#easy-source-solver-Yuning-Ding" class="headerlink" title="easy source (solver: Yuning Ding)"></a>easy source (solver: Yuning Ding)</h3><p>赛题结束后无法复现，只能大致口头描述了<br>扫描后台目录，有个index.php.swp,查看代码 构造payload:ip&#x2F;index.php?ra&#x3D;User&amp;rb&#x3D;q&amp;rc&#x3D;ReflectionMethod&amp;rd&#x3D;getDocComment 得到flag</p>
<h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><h3 id="rsa-solver-Yuning-Ding"><a href="#rsa-solver-Yuning-Ding" class="headerlink" title="rsa (solver: Yuning Ding)"></a>rsa (solver: Yuning Ding)</h3><p>分三部分加密，小公钥指数，共模，coopersmith。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## part1</span></span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span>* <span class="comment">#python第三方库 from gmpy2 import* #python第三方库</span></span><br><span class="line">n= <span class="number">12381447039455059836328051884891454693813773102677797588584673367249449397570306</span> <span class="number">97600538674718362494732908287999625868558926859029020506300183129390105649456766</span> <span class="number">99712246249820341712155938398068732866646422826619477180434858148938235662092482</span> 058999079105450136181685141895955574548671667320167741641072330259009</span><br><span class="line">c= <span class="number">19105765285510667553313898813498220212421177527647187802549913914263968945493144</span> <span class="number">63339067060511625106455036470478935883007213334910880879907502154047981518265766</span> <span class="number">77636171780441109394588346549225407041963304519793493530315785184791994544804581</span> <span class="number">37984734402248011464467312753683234543319955893</span></span><br><span class="line">i=<span class="number">0</span> <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span>(iroot(c+i*n,<span class="number">3</span>)[<span class="number">1</span>]==<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(iroot(c+i*n,<span class="number">3</span>)[<span class="number">0</span>]))</span><br><span class="line"><span class="keyword">break</span> i=i+<span class="number">1</span></span><br><span class="line"><span class="comment">## part2</span></span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> n2s,s2n <span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert <span class="comment"># 欧几里得算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">egcd</span>(<span class="params">a, b</span>):</span><br><span class="line">  <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> (b, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    g, y, x = egcd(b % a, a)</span><br><span class="line">    <span class="keyword">return</span> (g, x - (b // a) * y, y)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(): n=</span><br><span class="line"><span class="comment">#或者 iroot(c-i*n,3)</span></span><br><span class="line"><span class="number">11138196116958992789651255775428942047487763260733468530666797779493882401834579</span></span><br><span class="line"><span class="number">58363031614920765393759597316332706260914988439364019966488204510198115925945286</span></span><br><span class="line"><span class="number">73182109109991384472979198906744569181673282663323892346854520052840694924830064</span></span><br><span class="line"><span class="number">546269187849702880332522636682366270177489467478933966884097824069977</span></span><br><span class="line">  c1 =</span><br><span class="line"><span class="number">54995751387258798791895413216172284653407054079765769704170763023830130981480272</span></span><br><span class="line"><span class="number">94333844524568929372930820057421795901846251279052362225247925841949885830789811</span></span><br><span class="line"><span class="number">89070767734702535333448779595087662857305090678296844273757593456237016059970671</span></span><br><span class="line"><span class="number">35659404296663877453758701010726561824951602615501078818914410959610</span></span><br><span class="line">  c2 =</span><br><span class="line"><span class="number">91290935267458356541959327381220067466104890455391103989639822855753797805354139</span></span><br><span class="line"><span class="number">74195995795198394314610855276275644447554525034376679822034824037759011285489048</span></span><br><span class="line"><span class="number">23757448760161917734718537040147359366084362101536698294542881998388276464027425</span></span><br><span class="line"><span class="number">54134017280213707222338496271289894681312606239512924842845268366950</span></span><br><span class="line">e1 = <span class="number">17</span></span><br><span class="line">e2 = <span class="number">65537</span></span><br><span class="line">s = egcd(e1, e2) s1 = s[<span class="number">1</span>]</span><br><span class="line">s2 = s[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 求模反元素</span></span><br><span class="line"><span class="keyword">if</span> s1&lt;<span class="number">0</span>:</span><br><span class="line">s1 = - s1</span><br><span class="line">    c1 = invert(c1, n)</span><br><span class="line">  <span class="keyword">elif</span> s2&lt;<span class="number">0</span>:</span><br><span class="line">    s2 = - s2</span><br><span class="line">    c2 = invert(c2, n)</span><br><span class="line">  m = <span class="built_in">pow</span>(c1,s1,n)*<span class="built_in">pow</span>(c2,s2,n) % n</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">hex</span>(m))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main()</span><br><span class="line"><span class="comment">## part3，sage运行</span></span><br><span class="line">n=<span class="number">113432930155033263769270712825121761080813952100666693606866355917116416984149</span></span><br><span class="line"><span class="number">16550723192518059386083625540295035832742244735920068953721752854762369158600895</span></span><br><span class="line"><span class="number">26190638468018298026374488744512289576357075539802106859852158871073004169695490</span></span><br><span class="line"><span class="number">87293746310593988908287181025770739538992559714587375763131132963783147</span></span><br><span class="line">p=<span class="number">711728669592547291800107184697390034264010777021485892818841976562815147862023</span></span><br><span class="line"><span class="number">6042882657992902</span></span><br><span class="line">pbits = <span class="number">512</span></span><br><span class="line">kbits = pbits-p.nbits()</span><br><span class="line">p=p&lt;&lt;kbits</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;upper %d bits (of %d bits) is given&quot;</span> % (pbits-kbits, pbits))</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f=x+p</span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>] <span class="comment"># find root &lt; 2^kbits with factor</span></span><br><span class="line">&gt;= n^<span class="number">0.4</span></span><br><span class="line">    <span class="built_in">print</span>(p+<span class="built_in">int</span>(x0))</span><br><span class="line"><span class="comment">## flag</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes,bytes_to_long,getPrime</span><br><span class="line">a=<span class="number">0x200a4f2077696c6420576573742057696e642c2074686f7520627265617468206f6620417574</span></span><br><span class="line">756d6e2773206265696e672c0a54686f752c2066726f6d2077686f736520756e7365656e20707265</span><br><span class="line">73656e636520746865206c656176657320646561640a4172652064726976656e2c206c696b652067</span><br><span class="line">686f7374732066726f6d20616e20656e6368616e74657220666c6565696e672c0a59656c6c6f772c</span><br><span class="line">20616e6420626c61636b2c20616e642070616c652c20616e6420686563746963207265642c0a5065</span><br><span class="line">7374696c656e63652d73747269636b656e206d756c746974756465733a204f2074686f752c0a5768</span><br><span class="line">6f2063686172696f7465737420746f207468656972206461726b2077696e747279206265640a</span><br><span class="line">b=long_to_bytes(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">c=hashlib.md5(b).hexdigest()</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>

<h3 id="imageencrypt-solver-Jialin-Liu"><a href="#imageencrypt-solver-Jialin-Liu" class="headerlink" title="imageencrypt (solver: Jialin Liu)"></a>imageencrypt (solver: Jialin Liu)</h3><pre><code>i0=[205, 237, 6, 158, 24, 119, 213, 32, 74, 151, 142, 186, 57, 28, 113, 62, 165,
20, 190, 37, 159, 137, 196, 44, 97, 37, 7, 222, 220, 95, 4, 66, 0, 28, 199, 142,
95, 105, 119, 232, 250, 215, 60, 162, 91, 211, 63, 30, 91, 108, 217, 206, 80,
193, 230, 42, 221, 71, 136, 115, 22, 176, 91, 57, 61, 3, 87, 73, 250, 121, 51,
72, 83, 120, 77, 199, 236, 190, 249, 116, 45, 6, 134, 110, 149, 94, 214, 232,
153, 213, 119, 98, 81, 203, 240, 114, 240, 29, 122, 188, 156, 53, 128, 185, 40,
147, 245, 204, 47, 101, 80, 229, 41, 150, 28, 195, 25, 235, 119, 6, 192, 8, 73,
255, 159, 172, 77, 94, 254, 104, 236, 219, 141, 91, 195, 162, 97, 56, 252, 173,
163, 43, 167, 214, 50, 73, 115, 190, 254, 53, 61, 77, 138, 192, 15, 4, 190, 27,
37, 108, 101, 135, 90, 215, 106, 243, 112, 111, 106, 89, 143, 150, 185, 142,
192, 176, 48, 138, 164, 185, 61, 77, 72, 0, 17, 203, 210, 71, 186, 49, 162, 250,
218, 219, 195, 63, 248, 220, 155, 180, 219, 132, 219, 94, 144, 247, 211, 95, 70,
227, 222, 31, 69, 24, 13, 216, 185, 108, 137, 57, 186, 211, 55, 27, 158, 241,
223, 21, 134, 106, 152, 127, 187, 245, 246, 131, 176, 177, 228, 100, 112, 11,
84, 61, 193, 42, 41, 69, 229, 145, 254, 138, 3, 153, 123, 31]
i1=[131, 92, 72, 47, 177, 57, 131, 118, 4, 38, 192, 19, 119, 82, 63, 143, 235,
165, 15, 140, 209, 223, 117, 133, 47, 148, 81, 144, 138, 246, 173, 235, 177,
181, 110, 39, 9, 192, 57, 166, 180, 153, 141, 19, 234, 157, 142, 80, 234, 197,
151, 152, 249, 143, 176, 155, 147, 17, 57, 194, 191, 254, 13, 144, 140, 85, 25,
248, 172, 208, 154, 249, 5, 201, 27, 137, 69, 23, 175, 34, 156, 72, 208, 32,
195, 16, 127, 65, 207, 131, 57, 203, 7, 98, 89, 36, 65, 75, 211, 21, 45, 132,
214, 239, 102, 58, 68, 130, 97, 204, 225, 76, 152, 216, 74, 149, 79, 165, 198,
72, 150, 94, 7, 177, 46, 226, 252, 247, 79, 62, 69, 106, 60, 21, 106, 236, 47,
145, 170, 28, 18, 101, 14, 152, 131, 7, 37, 15, 168, 99, 115, 27, 220, 150, 89,
82, 232, 170, 107, 221, 212, 46, 235, 129, 36, 66, 217, 222, 36, 15, 217, 192,
247, 192, 113, 230, 129, 196, 13, 247, 148, 228, 225, 86, 71, 133, 132, 238,
236, 127, 11, 83, 107, 141, 114, 150, 182, 146, 213, 250, 141, 53, 114, 16, 198,
70, 133, 17, 247, 173, 136, 73, 236, 78, 188, 150, 239, 58, 199, 136, 11, 122,
134, 77, 47, 167, 137, 188, 55, 195, 41, 49, 245, 92, 160, 213, 254, 0, 85, 205,
193, 69, 2, 140, 143, 155, 127, 236, 179, 199, 168, 35, 85, 40, 45, 174]
i2=[198, 143, 247, 3, 152, 139, 131, 84, 181, 180, 252, 177, 192, 25, 217, 179,
136, 107, 190, 62, 4, 6, 90, 53, 105, 238, 117, 44, 5, 116, 132, 195, 214, 171,
113, 209, 18, 31, 194, 174, 228, 212, 196, 14, 27, 41, 211, 56, 139, 135, 225,
214, 89, 122, 178, 212, 185, 231, 204, 150, 204, 212, 160, 142, 213, 173, 186,
166, 65, 238, 5, 32, 45, 31, 25, 189, 148, 38, 78, 79, 33, 56, 227, 48, 103,
163, 31, 189, 37, 124, 106, 249, 86, 188, 86, 233, 41, 250, 89, 7, 212, 234,
111, 104, 245, 102, 227, 96, 160, 67, 181, 13, 26, 192, 214, 210, 188, 84, 216,
215, 243, 72, 233, 2, 122, 166, 107, 251, 70, 128, 94, 190, 185, 210, 34, 85,
77, 29, 182, 77, 115, 208, 228, 252, 73, 198, 151, 70, 10, 97, 138, 235, 21,
117, 239, 102, 129, 2, 253, 80, 53, 61, 184, 220, 41, 82, 37, 140, 23, 143, 179,
53, 153, 113, 213, 211, 111, 197, 248, 65, 60, 69, 1, 81, 48, 254, 251, 89, 195,
8, 93, 190, 66, 174, 97, 175, 210, 191, 66, 112, 123, 128, 33, 230, 237, 104,
16, 192, 239, 173, 44, 10, 120, 231, 114, 151, 140, 63, 103, 44, 243, 222, 242,
73, 51, 46, 98, 137, 163, 152, 147, 95, 223, 3, 15, 112, 85, 215, 133, 131, 240,
239, 224, 195, 140, 124, 70, 156, 221, 241, 37, 245, 1, 99, 9, 157, 99, 150, 47,
118, 225, 16, 13, 141, 135, 99, 18, 119, 63, 160, 6, 247, 27, 68, 45, 199, 86,
193, 252, 21, 135, 32, 42, 103, 114, 241, 49, 249, 182, 52, 18, 155, 157, 61, 4,
246, 158, 52, 118, 242, 195, 54, 139, 232, 100, 31, 11, 233, 58, 100, 101, 137,
83, 145, 209, 7, 241, 96, 57, 148, 207, 29, 237, 124, 177, 166, 161, 20, 116,
122, 61, 71, 46, 82, 18, 157, 253, 130, 112, 66, 94, 57, 221, 243, 222, 192,
147, 5, 130, 201, 174, 26, 160, 16, 188, 103, 187, 11, 238, 182, 144, 4, 137,
33, 84, 100, 7, 239, 219, 83, 112, 189, 166, 58, 93, 141, 30, 198, 220, 196,
118, 172, 5, 45]
ia0=[a^b for a,b in zip(i0,i1)]
print(len(ia0))
ia0
label = []
temp = &quot;&quot;
key2 = 0b01001110
key1 = 0b01010110
key1 = ~key1 &amp; 0xff
# key2 = ~key2 &amp; 0xff
for a in ia0:
    if a == key1:
        temp = temp+&quot;00&quot;
    elif a == ~key1 &amp; 0xff:
        temp = temp+&quot;01&quot;
    elif a == key2:
        temp = temp+&quot;10&quot;
    elif a == ~key2 &amp; 0xff:
        temp = temp+&quot;11&quot;
    if len(temp) == 16:
        label.append(int(temp, 2))
        temp = &quot;&quot;
label=np.array(label)
print(label.shape)
print(label)
label2=label/22000
print(label2)
for i in range(len(label2)-1):
    print(label2[i+1]/(label2[i]*(3-label2[i])))
import numpy as np
s = np.arange(0, 1, 0.000001)
result=[]
for x in s:
    seqs=[]
    for i in range(32):
        x = round(1.2*x*(3-x), 6)
        seqs.append(int(x*22000))
    pred=np.array(seqs)
    result.append(((label-pred)**2).mean())
result=np.abs(np.array(result))
result.min()
from matplotlib import pyplot as plt
plt.plot(result)
from matplotlib import pyplot as plt
plt.plot(result)
print(np.argmin(result))
result[np.argmin(result)]
seqs=[]
x=0.840264
for i in range(48):
    x = round(1.2*x*(3-x), 6)
    seqs.append(int(x*22000))
pred=np.array(seqs)
# print(((label-pred)**2).mean())
print(pred)
bins = &#39;&#39;
for x in pred:
    bin_x = bin(x)[2:]
    if len(bin_x) &lt; 16:
        bin_x = &#39;0&#39;*(16-len(bin_x))+bin_x
    bins += bin_x
m=24
n=16
cipher = [0 for i in range(m) for j in range(n)]
for i in range(m):
    for j in range(n):
        index = n*i+j
        ch = int(bins[2*index:2*index+2], 2)
        pix = i2[index]
        if ch == 0:
            pix = (pix ^ key1) &amp; 0xff
        if ch == 1:
            pix = (~pix ^ key1) &amp; 0xff
        if ch == 2:
            pix = (pix ^ key2) &amp; 0xff
        if ch == 3:
            pix = (~pix ^ key2) &amp; 0xff
        cipher[index] = pix
print(cipher)
print(len(cipher))
# print(i1)
</code></pre>
]]></content>
      <categories>
        <category>ciscn</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn2020公开赛 write-up</title>
    <url>/2020/08/25/ciscn2020/</url>
    <content><![CDATA[<blockquote>
<p>author:DUT-2020  solve：9 战队排名：27</p>
</blockquote>
<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="1-签到-（solver-Yuning-Ding）"><a href="#1-签到-（solver-Yuning-Ding）" class="headerlink" title="1 签到 （solver: Yuning Ding）"></a>1 签到 （solver: Yuning Ding）</h3><p>略</p>
<h3 id="2-the-best-ctf-game（solver-Yuning-Ding）"><a href="#2-the-best-ctf-game（solver-Yuning-Ding）" class="headerlink" title="2 the best ctf game（solver: Yuning Ding）"></a>2 the best ctf game（solver: Yuning Ding）</h3><p>用文本文档打开，把一些字符替换成空白，看到flag。（不小心删了附件，似乎附件比赛结束后不能下载了）</p>
<h3 id="3-dump-disk（solver-Yuning-Ding）"><a href="#3-dump-disk（solver-Yuning-Ding）" class="headerlink" title="3 dump_disk（solver: Yuning Ding）"></a>3 dump_disk（solver: Yuning Ding）</h3><p>使用mount命令挂载，看到一个png，一个elf和一个fakeflag，根据题意，猜测是误删文件，用extundelete工具恢复（工具内置于kali linux）</p>
<blockquote>
<p>sudo extundelete &#x2F;dev&#x2F;loop1 –restore-all</p>
</blockquote>
<p>得到一个加密后的flag，然后ida查看elf文件，发现加密流程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">68</span>,<span class="number">42</span>,<span class="number">3</span>,<span class="number">229</span>,<span class="number">41</span>,<span class="number">163</span>,<span class="number">175</span>,<span class="number">98</span>,<span class="number">5</span>,<span class="number">49</span>,<span class="number">78</span>,<span class="number">243</span>,<span class="number">214</span>,<span class="number">235</span>,<span class="number">144</span>,<span class="number">102</span>,<span class="number">36</span>,<span class="number">92</span>,<span class="number">183</span>,<span class="number">146</span>,<span class="number">246</span>,<span class="number">215</span>,<span class="number">77</span>,<span class="number">11</span>,<span class="number">106</span>,<span class="number">65</span>,<span class="number">163</span>,<span class="number">133</span>,<span class="number">239</span>,<span class="number">144</span>,<span class="number">90</span>,<span class="number">126</span>,<span class="number">91</span>,<span class="number">236</span>,<span class="number">193</span>,<span class="number">240</span>,<span class="number">212</span>,<span class="number">97</span>,<span class="number">18</span>,<span class="number">18</span>,<span class="number">69</span>,<span class="number">235</span>,<span class="number">184</span>]</span><br><span class="line">v4=<span class="number">34</span></span><br><span class="line">v5=<span class="number">0</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(a)-<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># print(v4,v5)</span></span><br><span class="line">    <span class="built_in">str</span>=<span class="built_in">str</span>+<span class="built_in">chr</span>(((a[i]^v4)-v5)%<span class="number">256</span>)</span><br><span class="line">    v5=(v5+<span class="number">2</span>)&amp;<span class="number">0xf</span></span><br><span class="line">    v4=v4+<span class="number">34</span></span><br><span class="line"><span class="comment"># flag&#123;e5d7c4ed-b8f6-4417-8317-b809fc26c047&#125;</span></span><br></pre></td></tr></table></figure>

<p>flag{e5d7c4ed-b8f6-4417-8317-b809fc26c047}</p>
<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><blockquote>
<p>第一次写正式的wp，比赛时的payload忘保存了，幸好还有环境，以下都是写wp的时候重新测试的，可能与提交的payload不完全相同（似乎flag跟之前不一样？不知道是不是错觉）</p>
</blockquote>
<h3 id="rceme-（solver-Yuning-Ding）"><a href="#rceme-（solver-Yuning-Ding）" class="headerlink" title="rceme （solver: Yuning Ding）"></a>rceme （solver: Yuning Ding）</h3><p>很容易想到system cat flag，根据给定的格式 $pattern &#x3D; ‘&#x2F;{if:([\s\S]+?)}([\s\S]*?){end\s+if}&#x2F;’; 以及限制的语法构造payload，得到&#x2F;?a&#x3D;{if:(%27sys%27.%27tem%27)(%27cat%20&#x2F;flag%27)}{end%20if} (system语法不可使用，所以进行了切割)</p>
<p>得到flag flag{5b8eaf10-a3c0-4697-a164-376b495f6800}</p>
<h3 id="easytrick-（solver-Yuning-Ding）"><a href="#easytrick-（solver-Yuning-Ding）" class="headerlink" title="easytrick （solver: Yuning Ding）"></a>easytrick （solver: Yuning Ding）</h3><p>我们要让构造符合题目中的要求，需要满足的条件有，trick1和trick2不能相等，trick1和trick2长度不能大于5，我们可以让trick为整数，这里设置为2，让trick2为double的2.00000000000001</p>
<p>发现比赛时候写的payload没保存，幸好还有环境，现写了一个payload：</p>
<p>?trick&#x3D;O:5:”trick”:2:{s:6:”trick1”;i:2;s:6:”trick2”;d:2.00000000000001;}</p>
<p>得到flag flag{8c02a599-2a41-462b-92ba-89efc8a79554}</p>
<h3 id="easyphp-（solver-Yuning-Ding）"><a href="#easyphp-（solver-Yuning-Ding）" class="headerlink" title="easyphp （solver: Yuning Ding）"></a>easyphp （solver: Yuning Ding）</h3><p>很显然是通过a和b来想办法进入phpinfo</p>
<p>对a的输入有一定的限制，看到call_user_func_array给了我灵感，可以把a设置为call_user_func,那么b很显然是pcntl_wait,所以payload为 ?a&#x3D;call_user_func&amp;b&#x3D;pcntl_wait</p>
<p>找到flag flag{a2dd41ac-377d-4148-931e-2adbe9c616c0}</p>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h3 id="z3-（solver-Yuning-Ding）"><a href="#z3-（solver-Yuning-Ding）" class="headerlink" title="z3 （solver: Yuning Ding）"></a>z3 （solver: Yuning Ding）</h3><p>使用z3库解题，每组是一个七元方程式,一共六组，方程左侧一致，右侧对应数组值（下面就是一组方程式的求解）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">s=Solver()</span><br><span class="line">a=[<span class="number">0</span>]*<span class="number">7</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    a[i]=Int(<span class="string">&#x27;a[&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">s.add( <span class="number">12</span> * a[<span class="number">0</span>] + <span class="number">53</span> * a[<span class="number">1</span>] + <span class="number">6</span> * a[<span class="number">2</span>] +<span class="number">34</span> * a[<span class="number">3</span>]+ <span class="number">58</span> * a[<span class="number">4</span>] + <span class="number">36</span> * a[<span class="number">5</span>] + a[<span class="number">6</span>]==<span class="number">0x3759</span>)</span><br><span class="line">s.add(<span class="number">83</span> * a[<span class="number">0</span>] + <span class="number">85</span> * a[<span class="number">1</span>] + <span class="number">12</span> * a[<span class="number">2</span>] +<span class="number">73</span> * a[<span class="number">3</span>]+ <span class="number">27</span> * a[<span class="number">4</span>] + <span class="number">96</span> * a[<span class="number">5</span>] + <span class="number">52</span>*a[<span class="number">6</span>]==<span class="number">0x8953</span>)</span><br><span class="line">s.add(<span class="number">78</span> * a[<span class="number">0</span>] + <span class="number">53</span> * a[<span class="number">1</span>] + <span class="number">24</span> * a[<span class="number">2</span>] +<span class="number">36</span> * a[<span class="number">3</span>]+ <span class="number">86</span> * a[<span class="number">4</span>] + <span class="number">25</span> * a[<span class="number">5</span>] + <span class="number">46</span>*a[<span class="number">6</span>]==<span class="number">0x7122</span>)</span><br><span class="line">s.add(<span class="number">39</span> * a[<span class="number">0</span>] + <span class="number">78</span> * a[<span class="number">1</span>] + <span class="number">52</span> * a[<span class="number">2</span>] +<span class="number">9</span> * a[<span class="number">3</span>]+ <span class="number">62</span> * a[<span class="number">4</span>] + <span class="number">37</span> * a[<span class="number">5</span>] + <span class="number">84</span>*a[<span class="number">6</span>]==<span class="number">0x81f9</span>)</span><br><span class="line">s.add(<span class="number">23</span> * a[<span class="number">0</span>] + <span class="number">6</span>* a[<span class="number">1</span>] + <span class="number">14</span> * a[<span class="number">2</span>] +<span class="number">74</span> * a[<span class="number">3</span>]+ <span class="number">48</span> * a[<span class="number">4</span>] + <span class="number">12</span> * a[<span class="number">5</span>] + <span class="number">83</span>*a[<span class="number">6</span>]==<span class="number">0x5524</span>)</span><br><span class="line">s.add(<span class="number">27</span> * a[<span class="number">0</span>] + <span class="number">85</span> * a[<span class="number">1</span>] + <span class="number">92</span> * a[<span class="number">2</span>] +<span class="number">42</span> * a[<span class="number">3</span>]+ <span class="number">48</span> * a[<span class="number">4</span>] + <span class="number">15</span> * a[<span class="number">5</span>] + <span class="number">72</span>*a[<span class="number">6</span>]==<span class="number">0x8971</span>)</span><br><span class="line">s.add(<span class="number">4</span> * a[<span class="number">0</span>] + <span class="number">6</span> * a[<span class="number">1</span>] + <span class="number">3</span> * a[<span class="number">2</span>] +<span class="number">67</span> * a[<span class="number">3</span>] + <span class="number">26</span> * a[<span class="number">5</span>] + <span class="number">68</span>*a[<span class="number">6</span>]==<span class="number">0x3a1d</span>)</span><br><span class="line">s.check()</span><br><span class="line"><span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure>

<p>将6组方程全部解完，得到flag</p>
<h3 id="hyperthread（solver-Yuning-Ding）"><a href="#hyperthread（solver-Yuning-Ding）" class="headerlink" title="hyperthread（solver: Yuning Ding）"></a>hyperthread（solver: Yuning Ding）</h3><p>调试程序，发现创建了几个线程，分析代码，第一个线程代码有junk code（addr jmp addr+1，需要恢复数据后重新生成正确代码），处理之后发现对输入的字符串进行了一系列运算，第二个线程是对输入的字符分别加0（就是没变化），最后比对，逆向写出算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#a是比对的数组</span></span><br><span class="line">b=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(a)):</span><br><span class="line">    tmp=((a[i]-<span class="number">35</span>)^<span class="number">0x23</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    tmp= <span class="string">&#x27;&#123;:08b&#125;&#x27;</span>.<span class="built_in">format</span>(tmp)</span><br><span class="line">    b.append(tmp)</span><br><span class="line">c=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    <span class="comment">#print(int(i[2:]+i[0:2],2))</span></span><br><span class="line">    c=c+<span class="built_in">chr</span>(<span class="built_in">int</span>(i[<span class="number">2</span>:]+i[<span class="number">0</span>:<span class="number">2</span>],<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>

<p>flag{a959951b-76ca-4784-add7-93583251ca92}</p>
<h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><h3 id="bd-（solver：Yuning-Ding）"><a href="#bd-（solver：Yuning-Ding）" class="headerlink" title="bd （solver：Yuning Ding）"></a>bd （solver：Yuning Ding）</h3><p>wiener attack，适用于e很大的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> ContinuedFractions, Arithmetic</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wiener_hack</span>(<span class="params">e, n</span>):</span><br><span class="line">    <span class="comment"># firstly git clone https://github.com/pablocelayes/rsa-wiener-attack.git !</span></span><br><span class="line">    frac = ContinuedFractions.rational_to_contfrac(e, n)</span><br><span class="line">    convergents = ContinuedFractions.convergents_from_contfrac(frac)</span><br><span class="line">    <span class="keyword">for</span> (k, d) <span class="keyword">in</span> convergents:</span><br><span class="line">        <span class="keyword">if</span> k != <span class="number">0</span> <span class="keyword">and</span> (e * d - <span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">            phi = (e * d - <span class="number">1</span>) // k</span><br><span class="line">            s = n - phi + <span class="number">1</span></span><br><span class="line">            discr = s * s - <span class="number">4</span> * n</span><br><span class="line">            <span class="keyword">if</span> (discr &gt;= <span class="number">0</span>):</span><br><span class="line">                t = Arithmetic.is_perfect_square(discr)</span><br><span class="line">                <span class="keyword">if</span> t != -<span class="number">1</span> <span class="keyword">and</span> (s + t) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Hacked!&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="number">86966590627372918010571457840724456774194080910694231109811773050866217415975647358784246153710824794652840306389428729923771431340699346354646708396564203957270393882105042714920060055401541794748437242707186192941546185666953574082803056612193004258064074902605834799171191314001030749992715155125694272289</span>   </span><br><span class="line">    e = <span class="number">46867417013414476511855705167486515292101865210840925173161828985833867821644239088991107524584028941183216735115986313719966458608881689802377181633111389920813814350964315420422257050287517851213109465823444767895817372377616723406116946259672358254060231210263961445286931270444042869857616609048537240249</span></span><br><span class="line"></span><br><span class="line">    c = <span class="number">37625098109081701774571613785279343908814425141123915351527903477451570893536663171806089364574293449414561630485312247061686191366669404389142347972565020570877175992098033759403318443705791866939363061966538210758611679849037990315161035649389943256526167843576617469134413191950908582922902210791377220066</span></span><br><span class="line"></span><br><span class="line">    d = wiener_hack(e, n)</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    <span class="built_in">print</span> long_to_bytes(m)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>flag{d3752538-90d0-c373-cfef-9247d3e16848}</p>
]]></content>
      <categories>
        <category>ciscn</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
</search>
